Time	Sum	Command
1470	6944	> builtin source /usr/local/Cellar/fish/3.1.2/share/fish/config.fish
81	81	-> set -g IFS \n\ \t
29	29	-> set -qg __fish_added_user_paths
31	31	-> set -g __fish_added_user_paths
6	32	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
26	26	--> not set -q __fish_initialized
15	15	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
13	414	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
28	28	--> status --is-interactive
18	373	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
25	25	---> not set -q STY
60	60	---> not string match -q -- 'eterm*' $TERM
18	204	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
26	26	----> set -q KONSOLE_PROFILE_NAME
33	33	----> string match -q -- "*:*" $ITERM_SESSION_ID
33	33	----> string match -q -- "st-*" $TERM
54	54	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
40	40	----> test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit
26	26	---> set -q fish_term24bit
40	40	---> set -g fish_term24bit 1
27	27	-> set -l __extra_completionsdir
35	35	-> set -l __extra_functionsdir
26	26	-> set -l __extra_confdir
10	296	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
59	59	--> test -f $__fish_data_dir/__fish_build_paths.fish
135	227	--> source $__fish_data_dir/__fish_build_paths.fish
36	36	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
28	28	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
28	28	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
28	28	-> set -l xdg_data_dirs
10	67	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
24	24	--> set -q XDG_DATA_DIRS
33	33	--> set xdg_data_dirs $__fish_data_dir
33	33	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
32	32	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
31	31	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
9	87	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
44	44	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
34	34	--> set -a vendor_completionsdirs $__extra_completionsdir
8	75	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
34	34	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
33	33	--> set -a vendor_functionsdirs $__extra_functionsdir
8	74	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
33	33	--> not contains -- $__extra_confdir $vendor_confdirs
33	33	--> set -a vendor_confdirs $__extra_confdir
9	87	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
24	24	--> not set -q fish_function_path
54	54	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
9	95	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
25	25	--> not set -q fish_complete_path
61	61	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
10	10	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
2	74	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
10	72	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
27	27	---> not set -q FISH_UNIT_TESTS_RUNNING
35	35	---> test -d /usr/xpg4/bin
13	13	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
25	25	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
8	8	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
265	900	-> __fish_set_locale
412	421	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_set_locale.fish
9	9	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
30	30	--> set -l LOCALE_VARS
31	31	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
32	32	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
35	35	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
29	86	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
9	57	---> if set -q $locale_var
            return 0
        ...
26	26	----> set -q $locale_var
22	22	----> return 0
14	14	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
5	44	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
39	39	--> test $__fish_initialized -lt 2300
5	27	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
22	22	--> status --is-login
35	203	-> __fish_reconstruct_path
45	45	--> set -l local_path $PATH
16	16	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
26	26	--> set -g __fish_added_user_paths
4	26	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
22	22	---> set -q fish_user_paths
55	55	--> set -xg PATH $local_path
6	6	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
19	54	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
10	10	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
4	4	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
27	27	-> set -l sourcelist
467	2470	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
127	283	--> set -l basename (string replace -r '^.*/' '' -- $file)
156	156	---> string replace -r '^.*/' '' -- $file
74	74	--> contains -- $basename $sourcelist
32	32	--> set sourcelist $sourcelist $basename
61	61	--> [ -f $file -a -r $file ]
159	304	--> source $file
29	29	---> set -q FZF_TMUX_HEIGHT
22	22	---> set -q FZF_DEFAULT_OPTS
21	21	---> set -q FZF_LEGACY_KEYBINDINGS
21	21	---> set -q FZF_DISABLE_KEYBINDINGS
21	21	---> set -q FZF_PREVIEW_FILE_CMD
22	22	---> set -q FZF_PREVIEW_DIR_CMD
9	9	---> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
132	190	--> set -l basename (string replace -r '^.*/' '' -- $file)
58	58	---> string replace -r '^.*/' '' -- $file
40	40	--> contains -- $basename $sourcelist
33	33	--> set sourcelist $sourcelist $basename
63	63	--> [ -f $file -a -r $file ]
246	923	--> source $file
13	667	---> if test "$FZF_DISABLE_KEYBINDINGS" -ne 1
    if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    end

    if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    end
...
39	39	----> test "$FZF_DISABLE_KEYBINDINGS" -ne 1
25	586	----> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    ...
31	31	-----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
85	85	-----> bind \ct '__fzf_find_file'
32	32	-----> bind \cr '__fzf_reverse_isearch'
29	29	-----> bind \ec '__fzf_cd'
29	29	-----> bind \eC '__fzf_cd --hidden'
29	29	-----> bind \cg '__fzf_open'
28	28	-----> bind \co '__fzf_open --editor'
26	298	-----> if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        ...
89	89	------> bind -M insert >/dev/null 2>/dev/null
34	34	------> bind -M insert \ct '__fzf_find_file'
30	30	------> bind -M insert \cr '__fzf_reverse_isearch'
31	31	------> bind -M insert \ec '__fzf_cd'
30	30	------> bind -M insert \eC '__fzf_cd --hidden'
29	29	------> bind -M insert \cg '__fzf_open'
29	29	------> bind -M insert \co '__fzf_open --editor'
4	29	----> if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    ...
25	25	-----> set -q FZF_COMPLETE
10	10	---> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
76	76	> builtin source /usr/local/Cellar/fish/3.1.2/etc/fish/config.fish
139	139	> builtin source /Users/nathan/.config/fish/config.fish
111	118	> source /Users/nathan/.config/fish/functions/fish_title.fish
7	7	-> function fish_title
  echo (status current-command)
...
61	284	> fish_title
179	223	-> echo (status current-command)
44	44	--> status current-command
380	434	> source /Users/nathan/.config/fish/functions/fish_prompt.fish
15	15	-> function _user_host_name -d "Displays the user and host name if connected via SSH"
  if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  end
...
10	10	-> function _directory -d "Writes the colorized present working directory"
  echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
...
12	12	-> function _node -d "Writes the node version if there is a package.json"
  if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  end
...
9	9	-> function _git_status -d "Writes the current git status, if there is one."
  set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
  if test -z $branch_name
    return
  end

  echo -s (set_color normal) " on "
  set -l dirty (command git status --porcelain ^/dev/null)
  if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  end
  echo -s "$branch_name" (set_color normal)

  set -l unpushed_changes (git cherry -v ^/dev/null)
  if test -z "$unpushed_changes"
    return
  end

  echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)

...
8	8	-> function fish_prompt -d "Write out the prompt"
  echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
...
41	17701	> __fish_on_interactive
248	17626	-> __fish_config_interactive
1264	1279	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_config_interactive.fish
15	15	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
5	45	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
40	40	---> test $__fish_initialized -lt 3000
3	30	--> if set -q __fish_config_interactive_done
        return
    ...
27	27	---> set -q __fish_config_interactive_done
28	28	--> set -g __fish_config_interactive_done
26	26	--> set -g __fish_active_key_bindings
3	27	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
24	24	---> not set -q fish_greeting
2	26	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
24	24	---> set -q fish_private_mode
12	12	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
2	31	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
29	29	---> test $__fish_initialized -lt 3100
17	95	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
25	25	---> not set -q FISH_UNIT_TESTS_RUNNING
4	53	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
49	49	----> not test -d $__fish_user_data_dir/generated_completions
7	257	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
27	27	---> status --is-interactive
10	223	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
121	121	----> functions -q fish_greeting
34	34	----> test -n "$fish_greeting"
58	58	----> echo $fish_greeting
36	36	--> set -l varargs --on-variable fish_key_bindings
73	320	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
42	42	---> set -a varargs --on-variable fish_color_$var
73	73	---> set -a varargs --on-variable fish_color_$var
55	55	---> set -a varargs --on-variable fish_color_$var
41	41	---> set -a varargs --on-variable fish_color_$var
36	36	---> set -a varargs --on-variable fish_color_$var
40	40	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
4	46	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
42	42	---> test -d /etc/init.d
87	87	--> complete -c [ --wraps test
31	31	--> complete -c ! --wraps not
238	476	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
238	238	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
19	19	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
49	9109	--> __fish_reload_key_bindings
36	74	---> __init_uvar fish_key_bindings fish_default_key_bindings
4	38	----> if not set --query $argv[1]
            set --universal $argv
        ...
34	34	-----> not set --query $argv[1]
3	48	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
45	45	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
7	676	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
167	669	----> not functions -q "$fish_key_bindings"
490	502	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_key_bindings.fish
12	12	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
62	62	---> set -g __fish_active_key_bindings "$fish_key_bindings"
41	41	---> set -g fish_bind_mode default
10	7909	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
33	33	----> test "$fish_key_bindings" = fish_default_key_bindings
167	7866	----> fish_default_key_bindings 2>/dev/null
6	72	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
36	36	------> contains -- -h $argv
30	30	------> contains -- --help $argv
9	108	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
25	25	------> not set -q argv[1]
36	36	------> bind --erase --all --preset
3	38	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
35	35	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
7	80	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
32	32	------> not contains -- -s $argv
41	41	------> set argv "-s" $argv
413	5740	-----> __fish_shared_key_bindings $argv
940	972	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_shared_key_bindings.fish
13	13	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
11	11	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
4	4	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
4	4	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
5	74	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
37	37	-------> contains -- -h $argv
32	32	-------> contains -- --help $argv
35	35	------> bind --preset $argv \cy yank
34	34	------> bind --preset $argv \ey yank-pop
39	39	------> bind --preset $argv -k right forward-char
36	36	------> bind --preset $argv -k left backward-char
34	34	------> bind --preset $argv \e\[C forward-char
34	34	------> bind --preset $argv \e\[D backward-char
39	39	------> bind --preset $argv \eOC forward-char
35	35	------> bind --preset $argv \eOD backward-char
34	34	------> bind --preset $argv -k ppage beginning-of-history
34	34	------> bind --preset $argv -k npage end-of-history
32	32	------> bind --preset $argv \cx fish_clipboard_copy
33	33	------> bind --preset $argv \cv fish_clipboard_paste
32	32	------> bind --preset $argv \e cancel
32	32	------> bind --preset $argv \t complete
33	33	------> bind --preset $argv \cs pager-toggle-search
37	37	------> bind --preset $argv --key btab complete-and-search
35	35	------> bind --preset $argv \e\n "commandline -i \n"
44	44	------> bind --preset $argv \e\r "commandline -i \n"
145	145	------> bind --preset $argv -k down down-or-search
72	72	------> bind --preset $argv -k up up-or-search
49	49	------> bind --preset $argv \e\[A up-or-search
35	35	------> bind --preset $argv \e\[B down-or-search
34	34	------> bind --preset $argv \eOA up-or-search
44	44	------> bind --preset $argv \eOB down-or-search
43	43	------> bind --preset $argv -k sright forward-bigword
36	36	------> bind --preset $argv -k sleft backward-bigword
35	35	------> bind --preset $argv \e\eOC nextd-or-forward-word
34	34	------> bind --preset $argv \e\eOD prevd-or-backward-word
46	46	------> bind --preset $argv \e\e\[C nextd-or-forward-word
35	35	------> bind --preset $argv \e\e\[D prevd-or-backward-word
34	34	------> bind --preset $argv \eO3C nextd-or-forward-word
34	34	------> bind --preset $argv \eO3D prevd-or-backward-word
34	34	------> bind --preset $argv \e\[3C nextd-or-forward-word
35	35	------> bind --preset $argv \e\[3D prevd-or-backward-word
36	36	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
37	37	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
36	36	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
35	35	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
41	41	------> bind --preset $argv \e\eOA history-token-search-backward
35	35	------> bind --preset $argv \e\eOB history-token-search-forward
35	35	------> bind --preset $argv \e\e\[A history-token-search-backward
37	37	------> bind --preset $argv \e\e\[B history-token-search-forward
35	35	------> bind --preset $argv \eO3A history-token-search-backward
36	36	------> bind --preset $argv \eO3B history-token-search-forward
35	35	------> bind --preset $argv \e\[3A history-token-search-backward
55	55	------> bind --preset $argv \e\[3B history-token-search-forward
42	42	------> bind --preset $argv \e\[1\;3A history-token-search-backward
46	46	------> bind --preset $argv \e\[1\;3B history-token-search-forward
35	35	------> bind --preset $argv \e\[1\;9A history-token-search-backward
34	34	------> bind --preset $argv \e\[1\;9B history-token-search-forward
34	34	------> bind --preset $argv \e. history-token-search-backward
33	33	------> bind --preset $argv \el __fish_list_current_token
33	33	------> bind --preset $argv \ew __fish_whatis_current_token
36	36	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
34	34	------> bind --preset $argv \cc __fish_cancel_commandline
33	33	------> bind --preset $argv \cu backward-kill-line
34	34	------> bind --preset $argv \cw backward-kill-path-component
34	34	------> bind --preset $argv \e\[F end-of-line
34	34	------> bind --preset $argv \e\[H beginning-of-line
37	37	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
34	34	------> bind --preset $argv \cd delete-or-exit
34	34	------> bind --preset $argv \es __fish_prepend_sudo
34	34	------> bind --preset $argv -k f1 __fish_man_page
34	34	------> bind --preset $argv \eh __fish_man_page
35	35	------> bind --preset $argv \ep '__fish_paginate'
33	33	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
33	33	------> bind --preset $argv \ee edit_command_buffer
35	35	------> bind --preset $argv \ev edit_command_buffer
189	879	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
332	332	-------> bind --list-modes | string match -v paste
107	107	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
59	59	-------> bind --preset -M $mode \e\[O false
49	49	-------> bind --preset -M $mode \e\[\?1004h false
58	58	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
44	44	-------> bind --preset -M $mode \e\[O false
41	41	-------> bind --preset -M $mode \e\[\?1004h false
131	553	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
282	282	-------> bind --list-modes | string match -v paste
87	87	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
53	53	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
48	48	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
41	41	------> bind --preset -M paste "" self-insert
41	41	------> bind --preset -M paste \r "commandline -i \n"
40	40	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
42	42	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
36	36	------> bind --preset -M paste " " self-insert-notfirst
44	44	-----> bind --preset $argv "" self-insert
42	42	-----> bind --preset $argv " " self-insert expand-abbr
41	41	-----> bind --preset $argv \n execute
39	39	-----> bind --preset $argv \r execute
40	40	-----> bind --preset $argv \ck kill-line
39	39	-----> bind --preset $argv \eOC forward-char
38	38	-----> bind --preset $argv \eOD backward-char
37	37	-----> bind --preset $argv \e\[C forward-char
41	41	-----> bind --preset $argv \e\[D backward-char
46	46	-----> bind --preset $argv -k right forward-char
45	45	-----> bind --preset $argv -k left backward-char
45	45	-----> bind --preset $argv -k dc delete-char
44	44	-----> bind --preset $argv -k backspace backward-delete-char
44	44	-----> bind --preset $argv \x7f backward-delete-char
39	39	-----> bind --preset $argv \e\[1~ beginning-of-line
36	36	-----> bind --preset $argv \e\[3~ delete-char
37	37	-----> bind --preset $argv \e\[4~ end-of-line
159	159	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
83	83	-----> bind --preset $argv -k end end-of-line 2>/dev/null
43	43	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
36	36	-----> bind --preset $argv \ca beginning-of-line
35	35	-----> bind --preset $argv \ce end-of-line
42	42	-----> bind --preset $argv \ch backward-delete-char
34	34	-----> bind --preset $argv \cp up-or-search
34	34	-----> bind --preset $argv \cn down-or-search
34	34	-----> bind --preset $argv \cf forward-char
35	35	-----> bind --preset $argv \cb backward-char
34	34	-----> bind --preset $argv \ct transpose-chars
34	34	-----> bind --preset $argv \et transpose-words
37	37	-----> bind --preset $argv \eu upcase-word
34	34	-----> bind --preset $argv \ec capitalize-word
35	35	-----> bind --preset $argv \e\x7f backward-kill-word
34	34	-----> bind --preset $argv \e\b backward-kill-word
33	33	-----> bind --preset $argv \eb backward-word
34	34	-----> bind --preset $argv \ef forward-word
36	36	-----> bind --preset $argv \e\[1\;5C forward-word
36	36	-----> bind --preset $argv \e\[1\;5D backward-word
34	34	-----> bind --preset $argv \e\< beginning-of-buffer
34	34	-----> bind --preset $argv \e\> end-of-buffer
33	33	-----> bind --preset $argv \ed kill-word
19	19	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
5	250	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
147	245	----> functions --query fish_user_key_bindings >/dev/null
98	98	-----> source /Users/nathan/.config/fish/functions/fish_user_key_bindings.fish
9	231	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
40	40	---> not set -q FISH_UNIT_TESTS_RUNNING
11	11	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
9	9	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
32	162	---> __fish_enable_bracketed_paste
130	130	----> printf "\e[?2004h"
4	37	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
33	33	---> set -q TMUX
16	16	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
3	192	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
119	189	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
70	70	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
16	4836	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
200	1986	---> not type -q __fish_command_not_found_handler
506	518	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/type.fish
12	12	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
31	31	----> set -q argv[1]
49	49	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
74	74	----> argparse -n type -x t,p,P $options -- $argv
3	39	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
36	36	-----> set -q _flag_help
27	27	----> set -l res 1
25	25	----> set -l mode normal
26	26	----> set -l multi no
25	25	----> set -l selection all
25	25	----> set -l short no
7	55	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	-----> set -q _flag_quiet
26	26	-----> set mode quiet
23	23	----> set -q _flag_all
31	31	----> set -q _flag_short
20	20	----> set -q _flag_no_functions
25	791	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	-----> set -l found 0
12	351	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
26	26	------> test $selection != files
3	87	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
84	84	-------> functions -q -- $i
5	226	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
172	221	-------> contains -- $i (builtin -n)
49	49	--------> builtin -n
32	32	-----> set -l paths
9	280	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	------> test $multi != yes
98	243	------> set paths (command -s -- $i)
145	145	-------> command -s -- $i
13	13	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
6	65	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	------> test $found = 0
29	29	------> test $mode != quiet
27	27	----> return $res
24	24	---> set -l os
3	40	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
37	37	----> test -r /etc/os-release
19	2770	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
33	33	----> contains -- suse $os
26	26	----> contains -- sles $os
26	26	----> test -f /usr/libexec/pk-command-not-found
25	25	----> test -f /usr/lib/command-not-found
24	24	----> test -f /run/current-system/sw/bin/command-not-found
71	1302	----> type -q command-not-found
23	23	-----> set -q argv[1]
43	43	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
62	62	-----> argparse -n type -x t,p,P $options -- $argv
3	27	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
24	24	------> set -q _flag_help
23	23	-----> set -l res 1
23	23	-----> set -l mode normal
24	24	-----> set -l multi no
24	24	-----> set -l selection all
23	23	-----> set -l short no
7	51	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
21	21	------> set -q _flag_quiet
23	23	------> set mode quiet
23	23	-----> set -q _flag_all
21	21	-----> set -q _flag_short
20	20	-----> set -q _flag_no_functions
30	817	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	------> set -l found 0
11	349	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
26	26	-------> test $selection != files
4	81	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
77	77	--------> functions -q -- $i
5	231	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
176	226	--------> contains -- $i (builtin -n)
50	50	---------> builtin -n
32	32	------> set -l paths
9	300	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	-------> test $multi != yes
99	263	-------> set paths (command -s -- $i)
164	164	--------> command -s -- $i
14	14	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
6	67	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	-------> test $found = 0
29	29	-------> test $mode != quiet
27	27	-----> return $res
77	1305	----> type -p -q pkgfile
25	25	-----> set -q argv[1]
47	47	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
71	71	-----> argparse -n type -x t,p,P $options -- $argv
3	29	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	------> set -q _flag_help
25	25	-----> set -l res 1
25	25	-----> set -l mode normal
26	26	-----> set -l multi no
25	25	-----> set -l selection all
25	25	-----> set -l short no
7	54	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	------> set -q _flag_quiet
25	25	------> set mode quiet
23	23	-----> set -q _flag_all
22	22	-----> set -q _flag_short
22	22	-----> set -q _flag_no_functions
27	782	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	------> set -l found 0
8	377	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	-------> test $selection != files
4	96	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
92	92	--------> functions -q -- $i
4	245	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
187	241	--------> contains -- $i (builtin -n)
54	54	---------> builtin -n
32	32	------> set -l paths
9	243	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	-------> test $multi != yes
98	206	-------> set paths (command -s -- $i)
108	108	--------> command -s -- $i
13	13	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
6	63	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	-------> test $found = 0
27	27	-------> test $mode != quiet
27	27	-----> return $res
10	10	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
46	46	--> set __fish_initialized 3100
34	34	-> functions -e __fish_on_interactive
95	107	> source /Users/nathan/.config/fish/functions/fish_mode_prompt.fish
12	12	-> function fish_mode_prompt --description 'Displays the current mode'
  # This is a function override, we handle displaying the mode in the prompt directly in `fish_prompt.fish`
  # See https://github.com/fish-shell/fish-shell/issues/3232#issuecomment-232670506
...
45	45	> fish_mode_prompt
38	69859	> fish_prompt
394	69821	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
30	66	--> _user_host_name
5	36	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
31	31	----> test -n "$SSH_TTY"
44	1385	--> _directory
308	1341	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
92	92	----> set_color --bold cyan
192	884	----> prompt_pwd
191	203	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/prompt_pwd.fish
12	12	------> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
38	38	-----> set -l options 'h/help'
38	38	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	36	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	------> set -q _flag_help
24	24	-----> set -q fish_prompt_pwd_dir_length
27	27	-----> set -l fish_prompt_pwd_dir_length 1
39	39	-----> set realhome ~
123	186	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
63	63	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	101	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
57	57	----> set_color normal
80	67897	--> _git_status
143	53757	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
1802	53614	----> __fish_git_prompt "%s" | sed 's/ //'
121	128	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_git_prompt.fish
7	7	------> function __fish_git_prompt
    # TODO: This name is deprecated, figure out a way to tell users.
    fish_git_prompt $argv
...
572	51684	-----> fish_git_prompt $argv
3398	5389	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_git_prompt.fish
17	17	-------> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null | string replace \t " ")

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end

    # For the return status
    test "$count" = "0 0"
...
8	8	-------> function fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    # Use our variables as defaults, but allow overrides via the local git config.
    # That means if neither is set, this stays empty.
    #
    # So "!= true" or "!= false" are useful tests if you want to do something by default.
    set -l informative (command git config --bool bash.showInformativeStatus)

    set -l dirty (command git config --bool bash.showDirtyState)
    if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    end

    set -l untracked (command git config --bool bash.showUntrackedFiles)
    if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    end

    if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
9	9	-------> function __fish_git_prompt_staged --description "fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]
    set -l staged
    set -l ret 0

    if test -n "$sha"
        # The "diff" functions all return > 0 if there _is_ a diff,
        # but we want to return 0 if there are staged changes.
        # So we invert the status.
        not command git diff-index --cached --quiet HEAD -- 2>/dev/null
        and set staged $___fish_git_prompt_char_stagedstate
        set ret $status
    else
        set staged $___fish_git_prompt_char_invalidstate
        set ret 2
    end
    echo $staged
    return $ret
...
9	9	-------> function __fish_git_prompt_untracked --description "fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l ret 1
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set ret $status
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
    return $ret
...
9	9	-------> function __fish_git_prompt_dirty --description "fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    # Like staged, invert the status because we want 0 to mean there are dirty files.
    not command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set -l os $status
    if test $os -eq 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
    return $os
...
50	50	-------> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
5	31	-------> if set -q __fish_git_prompt_showstashstate
    set -a ___fish_git_prompt_status_order stashstate
...
26	26	--------> set -q __fish_git_prompt_showstashstate
5	5	-------> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | count)
    set -l stashstate 0
    set -l stashfile "$argv[1]/logs/refs/stash"
    if set -q __fish_git_prompt_showstashstate; and test -e "$stashfile"
        set stashstate (count < $stashfile)
    end

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles + $stashstate 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
10	10	-------> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
5	5	-------> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
10	10	-------> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
4	4	-------> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
10	10	-------> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
29	29	-------> set -l varargs
85	367	-------> for var in repaint describe_style show_informative_status use_informative_chars showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
35	35	--------> set -a varargs --on-variable __fish_git_prompt_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_$var
44	44	-------> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
            # Clear init so we reset the chars next time.
            set -e ___fish_git_prompt_init
        end

        commandline -f repaint 2>/dev/null
    end
...
28	28	-------> set -l varargs
86	652	-------> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_color$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_color$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_color$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_color$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_color$var
45	45	--------> set -a varargs --on-variable __fish_git_prompt_color$var
44	44	--------> set -a varargs --on-variable __fish_git_prompt_color$var
44	44	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	-------> set -a varargs --on-variable __fish_git_prompt_showcolorhints
67	67	-------> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
29	29	-------> set -l varargs
71	502	-------> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
31	31	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
54	54	-------> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
7	80	------> if not command -sq git
        return 1
    ...
73	73	-------> not command -sq git
187	7157	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
6970	6970	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
40	40	------> test -n "$repo_info"
35	35	------> set -l git_dir $repo_info[1]
34	34	------> set -l inside_gitdir $repo_info[2]
32	32	------> set -l bare_repo $repo_info[3]
33	33	------> set -l inside_worktree $repo_info[4]
27	27	------> set -q repo_info[5]
31	31	------> set -l sha $repo_info[5]
139	5855	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
125	5716	-------> __fish_git_prompt_operation_branch_bare $repo_info
34	34	--------> set -l git_dir $argv[1]
32	32	--------> set -l inside_gitdir $argv[2]
32	32	--------> set -l bare_repo $argv[3]
25	25	--------> set -q argv[5]
31	31	--------> set -l sha $argv[5]
26	26	--------> set -l branch
31	31	--------> set -l operation
28	28	--------> set -l detached no
25	25	--------> set -l bare
26	26	--------> set -l step
26	26	--------> set -l total
26	26	--------> set -l os
43	257	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
35	35	---------> test -d $git_dir/rebase-merge
19	179	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
36	36	----------> test -d $git_dir/rebase-apply
32	32	----------> test -f $git_dir/MERGE_HEAD
31	31	----------> test -f $git_dir/CHERRY_PICK_HEAD
30	30	----------> test -f $git_dir/REVERT_HEAD
31	31	----------> test -f $git_dir/BISECT_LOG
4	37	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
33	33	---------> test -n "$step" -a -n "$total"
15	4797	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
29	29	---------> test -z "$branch"
189	4713	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4460	4460	----------> command git symbolic-ref HEAD 2>/dev/null
64	64	----------> set os $status
6	40	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
34	34	----------> test $os -ne 0
4	37	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
33	33	---------> test "true" = $inside_gitdir
35	35	--------> echo $operation
31	31	--------> echo $branch
29	29	--------> echo $detached
26	26	--------> echo $bare
35	35	------> set -l r $rbc[1]
31	31	------> set -l b $rbc[2]
31	31	------> set -l detached $rbc[3]
24	24	------> set -l w
23	23	------> set -l i
24	24	------> set -l s
24	24	------> set -l u
27	27	------> set -l c $rbc[4]
23	23	------> set -l p
26	26	------> set -l informative_status
20	17781	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
25	25	-------> not set -q ___fish_git_prompt_init
68	7013	-------> __fish_git_prompt_validate_chars
94	571	--------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
37	37	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
35	267	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
141	205	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
31	31	-----------> echo $char
59	602	--------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
40	40	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
6	110	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
36	81	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
30	30	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
10	245	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
142	209	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
34	34	-----------> echo $char
61	598	--------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	110	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	81	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
11	242	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
139	205	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
32	32	-----------> echo $char
58	584	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	108	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	81	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
10	234	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
133	198	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
31	31	-----------> echo $char
57	591	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	110	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	81	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
32	32	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
11	238	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
134	201	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
35	35	-----------> set -q $user_variable_name
32	32	-----------> echo $char
57	594	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	109	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
34	80	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
25	25	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
10	244	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
143	207	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
32	32	-----------> echo $char
60	587	--------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	106	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
24	24	----------> set -q argv[3]
31	77	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
9	235	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
131	199	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
36	36	-----------> set -q $user_variable_name
32	32	-----------> echo $char
57	585	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
6	109	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
34	80	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	235	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
131	198	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
35	35	-----------> set -q $user_variable_name
32	32	-----------> echo $char
58	583	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	108	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
35	81	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
25	25	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	234	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
134	197	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
31	31	-----------> echo $char
57	530	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
3	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
24	24	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
35	262	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
136	200	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
32	32	-----------> echo $char
56	560	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
3	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
45	45	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
38	277	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
28	28	----------> not set -q $variable
143	211	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
35	35	-----------> set -q $user_variable_name
33	33	-----------> echo $char
60	560	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
37	37	---------> set -l user_variable_name "$argv[1]"
31	31	---------> set -l char $argv[2]
27	27	---------> set -l user_variable
4	34	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
30	30	----------> set -q $user_variable_name
5	29	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
24	24	----------> set -q argv[3]
32	32	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
39	277	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
28	28	----------> not set -q $variable
143	210	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
33	33	-----------> echo $char
70	10696	-------> __fish_git_prompt_validate_colors
89	760	--------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
46	46	---------> set -l user_variable_name "$argv[1]"
26	26	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
27	27	---------> set -l default default_done
120	308	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
107	107	----------> count $argv
47	47	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	140	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	105	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
54	653	--------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
122	247	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
7	147	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
12	113	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
29	29	-----------> test -n "$user_variable"
36	36	-----------> set -g $variable $default
36	36	-----------> set -g $variable_done $default_done
54	648	--------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
34	34	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
31	31	---------> set -l user_variable_bright
28	28	---------> set -l default default_done
117	238	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
41	41	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
10	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
54	641	--------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
122	246	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
10	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
57	635	--------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
3	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
114	236	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
59	631	--------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
35	35	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l user_variable
4	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
29	29	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
110	222	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
40	40	----------> set default $___fish_git_prompt_color
32	32	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
10	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
54	637	--------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
35	35	---------> set -l user_variable_name "$argv[1]"
26	26	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
111	235	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
39	39	----------> count $argv
52	52	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
6	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
35	35	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
56	644	--------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
35	35	---------> set -l user_variable_name "$argv[1]"
26	26	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
120	241	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	139	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
17	2885	--------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
24	24	---------> set -q __fish_git_prompt_showcolorhints
60	650	---------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
33	33	----------> set -l user_variable_name "$argv[1]"
26	26	----------> set -l user_variable
3	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
116	239	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	-----------> count $argv
47	47	-----------> set default $___fish_git_prompt_color
34	34	-----------> set default_done $___fish_git_prompt_color_done
35	35	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	145	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
13	111	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
37	37	------------> set -g $variable $default
35	35	------------> set -g $variable_done $default_done
66	654	---------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
36	36	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
4	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
27	27	----------> set -l default default_done
117	241	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	-----------> count $argv
48	48	-----------> set default $___fish_git_prompt_color
34	34	-----------> set default_done $___fish_git_prompt_color_done
35	35	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	137	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
11	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
71	696	---------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
32	32	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
4	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
130	270	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	-----------> count $argv
61	61	-----------> set default "$argv[2]"
36	36	-----------> set default_done "$argv[3]"
37	37	----------> set -l variable _$user_variable_name
34	34	----------> set -l variable_done "$variable"_done
7	147	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
30	30	-----------> not set -q $variable
11	110	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
28	28	------------> test -n "$user_variable"
36	36	------------> set -g $variable $default
35	35	------------> set -g $variable_done $default_done
69	844	---------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
33	33	----------> set -l user_variable_name "$argv[1]"
26	26	----------> set -l user_variable
4	32	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	-----------> set -q $user_variable_name
26	26	----------> set -l user_variable_bright
27	27	----------> set -l default default_done
181	410	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
108	108	-----------> count $argv
81	81	-----------> set default "$argv[2]"
40	40	-----------> set default_done "$argv[3]"
36	36	----------> set -l variable _$user_variable_name
33	33	----------> set -l variable_done "$variable"_done
10	152	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
29	29	-----------> not set -q $variable
11	113	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
37	37	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
158	1188	--------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
44	44	---------> set_color red
40	40	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
4	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
29	29	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
143	517	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	----------> count $argv
114	114	----------> set default "$argv[2]"
166	216	----------> set default_done (set_color normal)
50	50	-----------> set_color normal
67	67	---------> set -l variable _$user_variable_name
66	66	---------> set -l variable_done "$variable"_done
9	184	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
54	54	----------> not set -q $variable
11	121	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
38	38	-----------> test -n "$user_variable"
37	37	-----------> set -g $variable $default
35	35	-----------> set -g $variable_done $default_done
61	649	--------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
33	33	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
120	244	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
49	49	----------> set default "$argv[2]"
33	33	----------> set default_done "$argv[3]"
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
10	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
65	655	--------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
33	33	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
119	247	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	----------> count $argv
49	49	----------> set default "$argv[2]"
35	35	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
27	27	-------> set -g ___fish_git_prompt_init
40	40	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
152	4667	------> set -l informative (command git config --bool bash.showInformativeStatus)
4515	4515	-------> command git config --bool bash.showInformativeStatus
159	4220	------> set -l dirty (command git config --bool bash.showDirtyState)
4061	4061	-------> command git config --bool bash.showDirtyState
11	65	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
29	29	-------> not set -q dirty[1]
25	25	-------> set -q __fish_git_prompt_showdirtystate
153	4132	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
3979	3979	-------> command git config --bool bash.showUntrackedFiles
11	67	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
30	30	-------> not set -q untracked[1]
26	26	-------> set -q __fish_git_prompt_showuntrackedfiles
11	251	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
34	34	-------> test "true" = $inside_worktree
10	153	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
27	27	--------> test "$informative" = true
7	30	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
23	23	---------> set -q __fish_git_prompt_show_informative_status
4	31	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
27	27	---------> test "$dirty" = true
4	26	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
22	22	---------> set -q __fish_git_prompt_showstashstate
4	29	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
25	25	---------> test "$untracked" = true
7	53	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
23	23	--------> set -q __fish_git_prompt_showupstream
23	23	--------> set -q __fish_git_prompt_show_informative_status
34	34	------> set -l branch_color $___fish_git_prompt_color_branch
31	31	------> set -l branch_done $___fish_git_prompt_color_branch_done
4	26	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
22	22	-------> set -q __fish_git_prompt_showcolorhints
4	30	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
26	26	-------> test -n "$w"
4	28	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
24	24	-------> test -n "$i"
3	27	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
24	24	-------> test -n "$s"
3	26	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
23	23	-------> test -n "$u"
133	184	------> set b (string replace refs/heads/ '' -- $b)
51	51	-------> string replace refs/heads/ '' -- $b
29	29	------> set -q __fish_git_prompt_shorten_branch_char_suffix
31	31	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
6	55	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
49	49	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
10	74	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
30	30	-------> test -n "$b"
34	34	-------> set b "$branch_color$b$branch_done"
4	30	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
26	26	-------> test -n "$c"
3	27	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
24	24	-------> test -n "$r"
4	28	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
24	24	-------> test -n "$p"
38	38	------> set -l f "$w$i$s$u"
4	29	------> if test -n "$f"
        set f "$space$f"
    ...
25	25	-------> test -n "$f"
32	32	------> set -l format $argv[1]
3	30	------> if test -z "$format"
        set format " (%s)"
    ...
27	27	-------> test -z "$format"
119	119	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
4	37	---> if test -z $branch_name
    return
  ...
33	33	----> test -z $branch_name
136	177	---> echo -s (set_color normal) " on "
41	41	----> set_color normal
179	7291	---> set -l dirty (command git status --porcelain ^/dev/null)
7112	7112	----> command git status --porcelain ^/dev/null
11	95	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
38	38	----> test -z "$dirty"
46	46	----> set_color --bold red
137	176	---> echo -s "$branch_name" (set_color normal)
39	39	----> set_color normal
192	5918	---> set -l unpushed_changes (git cherry -v ^/dev/null)
5726	5726	----> git cherry -v ^/dev/null
5	43	---> if test -z "$unpushed_changes"
    return
  ...
38	38	----> test -z "$unpushed_changes"
225	323	---> echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)
48	48	----> set_color --bold magenta
50	50	----> set_color normal
39	79	--> _node
6	40	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
34	34	----> test -f ./package.json
47	199	> fish_title
117	152	-> echo (status current-command)
35	35	--> status current-command
51	113	> __fish_disable_bracketed_paste exit
62	62	-> printf "\e[?2004l"
45	244	> fish_title exit
160	199	-> echo (status current-command)
39	39	--> status current-command
132	132	> exit
38	84	> __fish_disable_bracketed_paste 0
46	46	-> printf "\e[?2004l"
