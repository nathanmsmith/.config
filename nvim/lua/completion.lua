-- Some old config. TBD on if I'll like the new config better, so I'm keeping it around.
--
-- local cmp = require("cmp")
-- local luasnip = require("luasnip")
-- local lspkind = require("lspkind")
-- -- local cmp_autopairs = require("nvim-autopairs.completion.cmp")
--
-- -- old completion settings
-- -- vim.o.complete = ".,w,b,u"
-- -- vim.o.completeopt = "menu"
--
-- vim.opt.completeopt = { "menu", "menuone", "noselect" }
-- vim.opt.shortmess:append("c")
--
--
-- cmp.setup({
--   completion = {
--     autocomplete = false,
--   },
--   experimental = {
--     ghost_text = true,
--   },
--   formatting = {
--     format = function(entry, item)
--       local color_item = require("nvim-highlight-colors").format(entry, { kind = item.kind })
--       lspkind.cmp_format({
--         mode = "text",
--         maxwidth = 50,
--         menu = {
--           buffer = "[Buffer]",
--           nvim_lsp = "[LSP]",
--           luasnip = "[Snippet]",
--           path = "[Path]",
--         },
--       })
--       if color_item.abbr_hl_group then
--         item.kind_hl_group = color_item.abbr_hl_group
--         item.kind = color_item.abbr
--       end
--       return item
--     end,
--   },
--   snippet = {
--     expand = function(args)
--       require("luasnip").lsp_expand(args.body)
--     end,
--   },
--   mapping = {
--     ["<Tab>"] = cmp.mapping(function(fallback)
--       if cmp.visible() then
--         cmp.select_next_item()
--       elseif luasnip.expand_or_jumpable() then
--         luasnip.expand_or_jump()
--       elseif has_words_before() then
--         cmp.complete()
--       else
--         fallback()
--       end
--     end, { "i", "s" }),
--     ["<S-Tab>"] = cmp.mapping(function(fallback)
--       if cmp.visible() then
--         cmp.select_prev_item()
--       elseif luasnip.jumpable(-1) then
--         luasnip.jump(-1)
--       else
--         fallback()
--       end
--     end, { "i", "s" }),
--     ["<Down>"] = cmp.mapping(cmp.mapping.select_next_item({ behavior = cmp.SelectBehavior.Select }), { "i" }),
--     ["<Up>"] = cmp.mapping(cmp.mapping.select_prev_item({ behavior = cmp.SelectBehavior.Select }), { "i" }),
--     ["<C-n>"] = cmp.mapping({
--       c = function()
--         if cmp.visible() then
--           cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
--         else
--           vim.api.nvim_feedkeys(t("<Down>"), "n", true)
--         end
--       end,
--       i = function(fallback)
--         if cmp.visible() then
--           cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
--         else
--           fallback()
--         end
--       end,
--     }),
--     ["<C-p>"] = cmp.mapping({
--       c = function()
--         if cmp.visible() then
--           cmp.select_prev_item({ behavior = cmp.SelectBehavior.Select })
--         else
--           vim.api.nvim_feedkeys(t("<Up>"), "n", true)
--         end
--       end,
--       i = function(fallback)
--         if cmp.visible() then
--           cmp.select_prev_item({ behavior = cmp.SelectBehavior.Select })
--         else
--           fallback()
--         end
--       end,
--     }),
--     -- ["<C-b>"] = cmp.mapping(cmp.mapping.scroll_docs(-4), { "i", "c" }),
--     -- ["<C-f>"] = cmp.mapping(cmp.mapping.scroll_docs(4), { "i", "c" }),
--     ["<C-Space>"] = cmp.mapping(cmp.mapping.complete(), { "i", "c" }),
--     -- ["<C-e>"] = cmp.mapping({ i = cmp.mapping.close(), c = cmp.mapping.close() }),
--     ["<CR>"] = cmp.mapping({
--       i = cmp.mapping.confirm({ behavior = cmp.ConfirmBehavior.Replace, select = false }),
--       -- c = function(fallback)
--       --   if cmp.visible() then
--       --     cmp.confirm({ behavior = cmp.ConfirmBehavior.Replace, select = false })
--       --   else
--       --     fallback()
--       --   end
--       -- end,
--     }),
--   },
--   sources = cmp.config.sources({
--     -- { name = "cmp-nvim-lsp-signature-help" },
--     { name = "luasnip" },
--     { name = "nvim_lsp" },
--     { name = "lazydev" },
--     -- { name = "copilot" },
--     {
--       name = "buffer",
--       -- Get words from all visible buffers
--       -- https://github.com/hrsh7th/cmp-buffer?tab=readme-ov-file#visible-buffers
--       option = {
--         get_bufnrs = function()
--           local bufs = {}
--           for _, win in ipairs(vim.api.nvim_list_wins()) do
--             bufs[vim.api.nvim_win_get_buf(win)] = true
--           end
--           return vim.tbl_keys(bufs)
--         end,
--       },
--     },
--   }),
-- })
--
-- -- Autopairs support
-- -- https://github.com/windwp/nvim-autopairs
-- -- cmp.event:on("confirm_done", cmp_autopairs.on_confirm_done())
--
-- -- -- Use buffer source for `/`.
-- -- cmp.setup.cmdline("/", {
-- --   completion = { autocomplete = false },
-- --   sources = {
-- --     -- { name = 'buffer' }
-- --     { name = "buffer", opts = { keyword_pattern = [=[[^[:blank:]].*]=] } },
-- --   },
-- -- })
--
-- -- -- Use cmdline & path source for ':'.
-- -- cmp.setup.cmdline(":", {
-- --   completion = { autocomplete = false },
-- --   sources = cmp.config.sources({
-- --     { name = "path" },
-- --   }, {
-- --     { name = "cmdline" },
-- --   }),
-- -- })
