Time	Sum	Command
1199	6890	> builtin source /usr/local/Cellar/fish/3.1.2/share/fish/config.fish
64	64	-> set -g IFS \n\ \t
28	28	-> set -qg __fish_added_user_paths
27	27	-> set -g __fish_added_user_paths
4	29	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
25	25	--> not set -q __fish_initialized
14	14	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
8	381	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
27	27	--> status --is-interactive
16	346	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
23	23	---> not set -q STY
55	55	---> not string match -q -- 'eterm*' $TERM
19	195	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
24	24	----> set -q KONSOLE_PROFILE_NAME
32	32	----> string match -q -- "*:*" $ITERM_SESSION_ID
32	32	----> string match -q -- "st-*" $TERM
49	49	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
39	39	----> test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit
25	25	---> set -q fish_term24bit
32	32	---> set -g fish_term24bit 1
27	27	-> set -l __extra_completionsdir
25	25	-> set -l __extra_functionsdir
25	25	-> set -l __extra_confdir
10	269	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
51	51	--> test -f $__fish_data_dir/__fish_build_paths.fish
121	208	--> source $__fish_data_dir/__fish_build_paths.fish
34	34	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
27	27	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
26	26	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
27	27	-> set -l xdg_data_dirs
10	64	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
23	23	--> set -q XDG_DATA_DIRS
31	31	--> set xdg_data_dirs $__fish_data_dir
32	32	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
37	37	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
51	51	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
11	106	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
61	61	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
34	34	--> set -a vendor_completionsdirs $__extra_completionsdir
8	76	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
36	36	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
32	32	--> set -a vendor_functionsdirs $__extra_functionsdir
8	80	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
32	32	--> not contains -- $__extra_confdir $vendor_confdirs
40	40	--> set -a vendor_confdirs $__extra_confdir
8	80	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
22	22	--> not set -q fish_function_path
50	50	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
9	86	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
22	22	--> not set -q fish_complete_path
55	55	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
10	10	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
3	62	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
9	59	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
24	24	---> not set -q FISH_UNIT_TESTS_RUNNING
26	26	---> test -d /usr/xpg4/bin
14	14	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
25	25	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
8	8	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
273	917	-> __fish_set_locale
395	404	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_set_locale.fish
9	9	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
35	35	--> set -l LOCALE_VARS
34	34	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
38	38	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
36	36	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
34	97	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
10	63	---> if set -q $locale_var
            return 0
        ...
29	29	----> set -q $locale_var
24	24	----> return 0
15	15	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
6	49	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
43	43	--> test $__fish_initialized -lt 2300
5	30	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
25	25	--> status --is-login
41	272	-> __fish_reconstruct_path
73	73	--> set -l local_path $PATH
17	17	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
30	30	--> set -g __fish_added_user_paths
5	29	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
24	24	---> set -q fish_user_paths
82	82	--> set -xg PATH $local_path
7	7	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
23	62	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
11	11	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
10	10	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
4	4	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
31	31	-> set -l sourcelist
477	2657	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
145	311	--> set -l basename (string replace -r '^.*/' '' -- $file)
166	166	---> string replace -r '^.*/' '' -- $file
133	133	--> contains -- $basename $sourcelist
32	32	--> set sourcelist $sourcelist $basename
70	70	--> [ -f $file -a -r $file ]
192	348	--> source $file
33	33	---> set -q FZF_TMUX_HEIGHT
24	24	---> set -q FZF_DEFAULT_OPTS
23	23	---> set -q FZF_LEGACY_KEYBINDINGS
23	23	---> set -q FZF_DISABLE_KEYBINDINGS
22	22	---> set -q FZF_PREVIEW_FILE_CMD
22	22	---> set -q FZF_PREVIEW_DIR_CMD
9	9	---> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
118	174	--> set -l basename (string replace -r '^.*/' '' -- $file)
56	56	---> string replace -r '^.*/' '' -- $file
39	39	--> contains -- $basename $sourcelist
35	35	--> set sourcelist $sourcelist $basename
65	65	--> [ -f $file -a -r $file ]
262	973	--> source $file
11	700	---> if test "$FZF_DISABLE_KEYBINDINGS" -ne 1
    if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    end

    if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    end
...
42	42	----> test "$FZF_DISABLE_KEYBINDINGS" -ne 1
27	616	----> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    ...
33	33	-----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
88	88	-----> bind \ct '__fzf_find_file'
34	34	-----> bind \cr '__fzf_reverse_isearch'
31	31	-----> bind \ec '__fzf_cd'
30	30	-----> bind \eC '__fzf_cd --hidden'
30	30	-----> bind \cg '__fzf_open'
30	30	-----> bind \co '__fzf_open --editor'
25	313	-----> if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        ...
94	94	------> bind -M insert >/dev/null 2>/dev/null
37	37	------> bind -M insert \ct '__fzf_find_file'
32	32	------> bind -M insert \cr '__fzf_reverse_isearch'
32	32	------> bind -M insert \ec '__fzf_cd'
31	31	------> bind -M insert \eC '__fzf_cd --hidden'
31	31	------> bind -M insert \cg '__fzf_open'
31	31	------> bind -M insert \co '__fzf_open --editor'
6	31	----> if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    ...
25	25	-----> set -q FZF_COMPLETE
11	11	---> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
92	92	> builtin source /usr/local/Cellar/fish/3.1.2/etc/fish/config.fish
229	429	> builtin source /Users/nathan/.config/fish/config.fish
11	200	-> if status --is-login
  # PATH settings
  # GNU utils
  set -x PATH /usr/local/opt/{coreutils,findutils,grep,gnu-sed,gnu-time,make,gnu-units}/libexec/gnubin $PATH
  # Curl
  set -x PATH /usr/local/opt/curl/bin $PATH
  # Use installed LLVM tools
  set -x PATH /usr/local/opt/llvm/bin $PATH
  # Python
  set -x PATH "/usr/local/opt/python@3.8/bin" $PATH
  # Ruby
  set -x PATH /usr/local/lib/ruby/gems/2.7.0/bin /usr/local/opt/ruby/bin $PATH
...
189	189	--> status --is-login
107	114	> source /Users/nathan/.config/fish/functions/fish_title.fish
7	7	-> function fish_title
  echo (status current-command)
...
50	312	> fish_title
218	262	-> echo (status current-command)
44	44	--> status current-command
373	427	> source /Users/nathan/.config/fish/functions/fish_prompt.fish
16	16	-> function _user_host_name -d "Displays the user and host name if connected via SSH"
  if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  end
...
10	10	-> function _directory -d "Writes the colorized present working directory"
  echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
...
12	12	-> function _node -d "Writes the node version if there is a package.json"
  if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  end
...
8	8	-> function _git_status -d "Writes the current git status, if there is one."
  set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
  if test -z $branch_name
    return
  end

  echo -s (set_color normal) " on "
  set -l dirty (command git status --porcelain ^/dev/null)
  if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  end
  echo -s "$branch_name" (set_color normal)

  set -l unpushed_changes (git cherry -v ^/dev/null)
  if test -z "$unpushed_changes"
    return
  end

  echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)

...
8	8	-> function fish_prompt -d "Write out the prompt"
  echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
...
44	17015	> __fish_on_interactive
335	16936	-> __fish_config_interactive
1365	1381	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_config_interactive.fish
16	16	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
5	46	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
41	41	---> test $__fish_initialized -lt 3000
3	30	--> if set -q __fish_config_interactive_done
        return
    ...
27	27	---> set -q __fish_config_interactive_done
28	28	--> set -g __fish_config_interactive_done
25	25	--> set -g __fish_active_key_bindings
3	27	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
24	24	---> not set -q fish_greeting
3	25	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
22	22	---> set -q fish_private_mode
11	11	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
3	31	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
28	28	---> test $__fish_initialized -lt 3100
10	88	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
24	24	---> not set -q FISH_UNIT_TESTS_RUNNING
3	54	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
51	51	----> not test -d $__fish_user_data_dir/generated_completions
6	200	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
28	28	---> status --is-interactive
8	166	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
127	127	----> functions -q fish_greeting
31	31	----> test -n "$fish_greeting"
30	30	--> set -l varargs --on-variable fish_key_bindings
40	239	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
36	36	---> set -a varargs --on-variable fish_color_$var
36	36	---> set -a varargs --on-variable fish_color_$var
48	48	---> set -a varargs --on-variable fish_color_$var
40	40	---> set -a varargs --on-variable fish_color_$var
39	39	---> set -a varargs --on-variable fish_color_$var
105	105	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
10	122	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
112	112	---> test -d /etc/init.d
174	174	--> complete -c [ --wraps test
39	39	--> complete -c ! --wraps not
312	609	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
297	297	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
17	17	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
54	7173	--> __fish_reload_key_bindings
59	114	---> __init_uvar fish_key_bindings fish_default_key_bindings
5	55	----> if not set --query $argv[1]
            set --universal $argv
        ...
50	50	-----> not set --query $argv[1]
5	56	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
51	51	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
6	664	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
168	658	----> not functions -q "$fish_key_bindings"
478	490	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_key_bindings.fish
12	12	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
53	53	---> set -g __fish_active_key_bindings "$fish_key_bindings"
29	29	---> set -g fish_bind_mode default
7	6101	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
32	32	----> test "$fish_key_bindings" = fish_default_key_bindings
146	6062	----> fish_default_key_bindings 2>/dev/null
6	69	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
34	34	------> contains -- -h $argv
29	29	------> contains -- --help $argv
11	108	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
24	24	------> not set -q argv[1]
37	37	------> bind --erase --all --preset
3	36	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
33	33	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
7	66	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
30	30	------> not contains -- -s $argv
29	29	------> set argv "-s" $argv
310	4390	-----> __fish_shared_key_bindings $argv
786	818	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_shared_key_bindings.fish
12	12	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
11	11	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
5	5	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
4	4	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
7	77	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
41	41	-------> contains -- -h $argv
29	29	-------> contains -- --help $argv
33	33	------> bind --preset $argv \cy yank
31	31	------> bind --preset $argv \ey yank-pop
36	36	------> bind --preset $argv -k right forward-char
32	32	------> bind --preset $argv -k left backward-char
31	31	------> bind --preset $argv \e\[C forward-char
30	30	------> bind --preset $argv \e\[D backward-char
30	30	------> bind --preset $argv \eOC forward-char
29	29	------> bind --preset $argv \eOD backward-char
31	31	------> bind --preset $argv -k ppage beginning-of-history
31	31	------> bind --preset $argv -k npage end-of-history
34	34	------> bind --preset $argv \cx fish_clipboard_copy
30	30	------> bind --preset $argv \cv fish_clipboard_paste
30	30	------> bind --preset $argv \e cancel
29	29	------> bind --preset $argv \t complete
29	29	------> bind --preset $argv \cs pager-toggle-search
31	31	------> bind --preset $argv --key btab complete-and-search
32	32	------> bind --preset $argv \e\n "commandline -i \n"
31	31	------> bind --preset $argv \e\r "commandline -i \n"
40	40	------> bind --preset $argv -k down down-or-search
33	33	------> bind --preset $argv -k up up-or-search
31	31	------> bind --preset $argv \e\[A up-or-search
33	33	------> bind --preset $argv \e\[B down-or-search
30	30	------> bind --preset $argv \eOA up-or-search
29	29	------> bind --preset $argv \eOB down-or-search
33	33	------> bind --preset $argv -k sright forward-bigword
32	32	------> bind --preset $argv -k sleft backward-bigword
31	31	------> bind --preset $argv \e\eOC nextd-or-forward-word
30	30	------> bind --preset $argv \e\eOD prevd-or-backward-word
31	31	------> bind --preset $argv \e\e\[C nextd-or-forward-word
31	31	------> bind --preset $argv \e\e\[D prevd-or-backward-word
31	31	------> bind --preset $argv \eO3C nextd-or-forward-word
30	30	------> bind --preset $argv \eO3D prevd-or-backward-word
34	34	------> bind --preset $argv \e\[3C nextd-or-forward-word
30	30	------> bind --preset $argv \e\[3D prevd-or-backward-word
31	31	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
31	31	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
32	32	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
31	31	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
31	31	------> bind --preset $argv \e\eOA history-token-search-backward
30	30	------> bind --preset $argv \e\eOB history-token-search-forward
34	34	------> bind --preset $argv \e\e\[A history-token-search-backward
30	30	------> bind --preset $argv \e\e\[B history-token-search-forward
30	30	------> bind --preset $argv \eO3A history-token-search-backward
29	29	------> bind --preset $argv \eO3B history-token-search-forward
30	30	------> bind --preset $argv \e\[3A history-token-search-backward
30	30	------> bind --preset $argv \e\[3B history-token-search-forward
31	31	------> bind --preset $argv \e\[1\;3A history-token-search-backward
31	31	------> bind --preset $argv \e\[1\;3B history-token-search-forward
31	31	------> bind --preset $argv \e\[1\;9A history-token-search-backward
34	34	------> bind --preset $argv \e\[1\;9B history-token-search-forward
30	30	------> bind --preset $argv \e. history-token-search-backward
30	30	------> bind --preset $argv \el __fish_list_current_token
31	31	------> bind --preset $argv \ew __fish_whatis_current_token
33	33	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
30	30	------> bind --preset $argv \cc __fish_cancel_commandline
30	30	------> bind --preset $argv \cu backward-kill-line
30	30	------> bind --preset $argv \cw backward-kill-path-component
34	34	------> bind --preset $argv \e\[F end-of-line
31	31	------> bind --preset $argv \e\[H beginning-of-line
33	33	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
30	30	------> bind --preset $argv \cd delete-or-exit
30	30	------> bind --preset $argv \es __fish_prepend_sudo
31	31	------> bind --preset $argv -k f1 __fish_man_page
30	30	------> bind --preset $argv \eh __fish_man_page
30	30	------> bind --preset $argv \ep '__fish_paginate'
34	34	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
29	29	------> bind --preset $argv \ee edit_command_buffer
30	30	------> bind --preset $argv \ev edit_command_buffer
99	522	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
193	193	-------> bind --list-modes | string match -v paste
57	57	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
37	37	-------> bind --preset -M $mode \e\[O false
35	35	-------> bind --preset -M $mode \e\[\?1004h false
35	35	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
33	33	-------> bind --preset -M $mode \e\[O false
33	33	-------> bind --preset -M $mode \e\[\?1004h false
83	356	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
179	179	-------> bind --list-modes | string match -v paste
54	54	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
40	40	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
34	34	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
29	29	------> bind --preset -M paste "" self-insert
31	31	------> bind --preset -M paste \r "commandline -i \n"
32	32	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
31	31	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
29	29	------> bind --preset -M paste " " self-insert-notfirst
31	31	-----> bind --preset $argv "" self-insert
32	32	-----> bind --preset $argv " " self-insert expand-abbr
31	31	-----> bind --preset $argv \n execute
29	29	-----> bind --preset $argv \r execute
30	30	-----> bind --preset $argv \ck kill-line
30	30	-----> bind --preset $argv \eOC forward-char
29	29	-----> bind --preset $argv \eOD backward-char
30	30	-----> bind --preset $argv \e\[C forward-char
29	29	-----> bind --preset $argv \e\[D backward-char
31	31	-----> bind --preset $argv -k right forward-char
30	30	-----> bind --preset $argv -k left backward-char
31	31	-----> bind --preset $argv -k dc delete-char
31	31	-----> bind --preset $argv -k backspace backward-delete-char
29	29	-----> bind --preset $argv \x7f backward-delete-char
32	32	-----> bind --preset $argv \e\[1~ beginning-of-line
30	30	-----> bind --preset $argv \e\[3~ delete-char
30	30	-----> bind --preset $argv \e\[4~ end-of-line
56	56	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
52	52	-----> bind --preset $argv -k end end-of-line 2>/dev/null
34	34	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
31	31	-----> bind --preset $argv \ca beginning-of-line
30	30	-----> bind --preset $argv \ce end-of-line
30	30	-----> bind --preset $argv \ch backward-delete-char
29	29	-----> bind --preset $argv \cp up-or-search
30	30	-----> bind --preset $argv \cn down-or-search
29	29	-----> bind --preset $argv \cf forward-char
30	30	-----> bind --preset $argv \cb backward-char
30	30	-----> bind --preset $argv \ct transpose-chars
30	30	-----> bind --preset $argv \et transpose-words
29	29	-----> bind --preset $argv \eu upcase-word
30	30	-----> bind --preset $argv \ec capitalize-word
30	30	-----> bind --preset $argv \e\x7f backward-kill-word
31	31	-----> bind --preset $argv \e\b backward-kill-word
30	30	-----> bind --preset $argv \eb backward-word
35	35	-----> bind --preset $argv \ef forward-word
33	33	-----> bind --preset $argv \e\[1\;5C forward-word
32	32	-----> bind --preset $argv \e\[1\;5D backward-word
31	31	-----> bind --preset $argv \e\< beginning-of-buffer
30	30	-----> bind --preset $argv \e\> end-of-buffer
29	29	-----> bind --preset $argv \ed kill-word
17	17	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
4	102	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
98	98	----> functions --query fish_user_key_bindings >/dev/null
13	195	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
28	28	---> not set -q FISH_UNIT_TESTS_RUNNING
9	9	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
10	10	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
28	135	---> __fish_enable_bracketed_paste
107	107	----> printf "\e[?2004h"
5	32	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
27	27	---> set -q TMUX
18	18	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
4	168	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
109	164	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
55	55	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
27	5741	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
256	2132	---> not type -q __fish_command_not_found_handler
481	492	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/type.fish
11	11	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
29	29	----> set -q argv[1]
46	46	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
76	76	----> argparse -n type -x t,p,P $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -l res 1
23	23	----> set -l mode normal
24	24	----> set -l multi no
23	23	----> set -l selection all
23	23	----> set -l short no
6	50	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
21	21	-----> set -q _flag_quiet
23	23	-----> set mode quiet
21	21	----> set -q _flag_all
21	21	----> set -q _flag_short
20	20	----> set -q _flag_no_functions
26	911	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	-----> set -l found 0
6	342	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
27	27	------> test $selection != files
3	83	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
80	80	-------> functions -q -- $i
5	226	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
170	221	-------> contains -- $i (builtin -n)
51	51	--------> builtin -n
31	31	-----> set -l paths
8	404	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
34	34	------> test $multi != yes
87	362	------> set paths (command -s -- $i)
275	275	-------> command -s -- $i
12	12	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	71	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	------> test $found = 0
36	36	------> test $mode != quiet
64	64	----> return $res
70	70	---> set -l os
5	98	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
93	93	----> test -r /etc/os-release
21	3414	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
41	41	----> contains -- suse $os
30	30	----> contains -- sles $os
29	29	----> test -f /usr/libexec/pk-command-not-found
27	27	----> test -f /usr/lib/command-not-found
43	43	----> test -f /run/current-system/sw/bin/command-not-found
87	1643	----> type -q command-not-found
42	42	-----> set -q argv[1]
109	109	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-----> argparse -n type -x t,p,P $options -- $argv
3	29	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	------> set -q _flag_help
57	57	-----> set -l res 1
54	54	-----> set -l mode normal
26	26	-----> set -l multi no
26	26	-----> set -l selection all
25	25	-----> set -l short no
6	54	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	------> set -q _flag_quiet
25	25	------> set mode quiet
23	23	-----> set -q _flag_all
51	51	-----> set -q _flag_short
22	22	-----> set -q _flag_no_functions
30	941	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	------> set -l found 0
9	389	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	-------> test $selection != files
3	95	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
92	92	--------> functions -q -- $i
5	257	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
197	252	--------> contains -- $i (builtin -n)
55	55	---------> builtin -n
34	34	------> set -l paths
10	380	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	-------> test $multi != yes
102	340	-------> set paths (command -s -- $i)
238	238	--------> command -s -- $i
13	13	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	68	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	-------> test $found = 0
29	29	-------> test $mode != quiet
27	27	-----> return $res
108	1569	----> type -p -q pkgfile
25	25	-----> set -q argv[1]
46	46	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
71	71	-----> argparse -n type -x t,p,P $options -- $argv
3	28	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	------> set -q _flag_help
77	77	-----> set -l res 1
47	47	-----> set -l mode normal
27	27	-----> set -l multi no
25	25	-----> set -l selection all
24	24	-----> set -l short no
9	67	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
33	33	------> set -q _flag_quiet
25	25	------> set mode quiet
24	24	-----> set -q _flag_all
22	22	-----> set -q _flag_short
21	21	-----> set -q _flag_no_functions
34	930	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	------> set -l found 0
14	381	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	-------> test $selection != files
4	90	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
86	86	--------> functions -q -- $i
5	248	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
190	243	--------> contains -- $i (builtin -n)
53	53	---------> builtin -n
53	53	------> set -l paths
7	348	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	-------> test $multi != yes
90	311	-------> set paths (command -s -- $i)
221	221	--------> command -s -- $i
12	12	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	74	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
39	39	-------> test $found = 0
28	28	-------> test $mode != quiet
27	27	-----> return $res
11	11	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
47	47	--> set __fish_initialized 3100
35	35	-> functions -e __fish_on_interactive
175	206	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_mode_prompt.fish
31	31	-> function fish_mode_prompt --description "Displays the current mode"
    # To reuse the mode indicator use this function instead
    fish_default_mode_prompt
...
65	603	> fish_mode_prompt
203	538	-> fish_default_mode_prompt
231	245	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_mode_prompt.fish
14	14	---> function fish_default_mode_prompt --description "Display the default mode for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    end
...
10	90	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
45	45	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
52	64100	> fish_prompt
473	64048	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
31	69	--> _user_host_name
6	38	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
32	32	----> test -n "$SSH_TTY"
42	1385	--> _directory
291	1343	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
104	104	----> set_color --bold cyan
201	893	----> prompt_pwd
197	212	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/prompt_pwd.fish
15	15	------> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
38	38	-----> set -l options 'h/help'
42	42	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	------> set -q _flag_help
24	24	-----> set -q fish_prompt_pwd_dir_length
28	28	-----> set -l fish_prompt_pwd_dir_length 1
41	41	-----> set realhome ~
109	178	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
69	69	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	99	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
55	55	----> set_color normal
72	62039	--> _git_status
145	49189	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
1014	49044	----> __fish_git_prompt "%s" | sed 's/ //'
114	121	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_git_prompt.fish
7	7	------> function __fish_git_prompt
    # TODO: This name is deprecated, figure out a way to tell users.
    fish_git_prompt $argv
...
361	47909	-----> fish_git_prompt $argv
2773	4767	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_git_prompt.fish
16	16	-------> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null | string replace \t " ")

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end

    # For the return status
    test "$count" = "0 0"
...
9	9	-------> function fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    # Use our variables as defaults, but allow overrides via the local git config.
    # That means if neither is set, this stays empty.
    #
    # So "!= true" or "!= false" are useful tests if you want to do something by default.
    set -l informative (command git config --bool bash.showInformativeStatus)

    set -l dirty (command git config --bool bash.showDirtyState)
    if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    end

    set -l untracked (command git config --bool bash.showUntrackedFiles)
    if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    end

    if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
11	11	-------> function __fish_git_prompt_staged --description "fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]
    set -l staged
    set -l ret 0

    if test -n "$sha"
        # The "diff" functions all return > 0 if there _is_ a diff,
        # but we want to return 0 if there are staged changes.
        # So we invert the status.
        not command git diff-index --cached --quiet HEAD -- 2>/dev/null
        and set staged $___fish_git_prompt_char_stagedstate
        set ret $status
    else
        set staged $___fish_git_prompt_char_invalidstate
        set ret 2
    end
    echo $staged
    return $ret
...
9	9	-------> function __fish_git_prompt_untracked --description "fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l ret 1
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set ret $status
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
    return $ret
...
9	9	-------> function __fish_git_prompt_dirty --description "fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    # Like staged, invert the status because we want 0 to mean there are dirty files.
    not command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set -l os $status
    if test $os -eq 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
    return $os
...
45	45	-------> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
5	30	-------> if set -q __fish_git_prompt_showstashstate
    set -a ___fish_git_prompt_status_order stashstate
...
25	25	--------> set -q __fish_git_prompt_showstashstate
5	5	-------> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | count)
    set -l stashstate 0
    set -l stashfile "$argv[1]/logs/refs/stash"
    if set -q __fish_git_prompt_showstashstate; and test -e "$stashfile"
        set stashstate (count < $stashfile)
    end

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles + $stashstate 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
12	12	-------> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
4	4	-------> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
8	8	-------> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
6	6	-------> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
8	8	-------> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
29	29	-------> set -l varargs
83	371	-------> for var in repaint describe_style show_informative_status use_informative_chars showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
43	43	--------> set -a varargs --on-variable __fish_git_prompt_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_$var
44	44	-------> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
            # Clear init so we reset the chars next time.
            set -e ___fish_git_prompt_init
        end

        commandline -f repaint 2>/dev/null
    end
...
29	29	-------> set -l varargs
90	651	-------> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_color$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_color$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_color$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
43	43	--------> set -a varargs --on-variable __fish_git_prompt_color$var
46	46	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	-------> set -a varargs --on-variable __fish_git_prompt_showcolorhints
68	68	-------> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
30	30	-------> set -l varargs
70	503	-------> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
55	55	-------> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
7	176	------> if not command -sq git
        return 1
    ...
169	169	-------> not command -sq git
208	4634	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4426	4426	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
35	35	------> test -n "$repo_info"
31	31	------> set -l git_dir $repo_info[1]
30	30	------> set -l inside_gitdir $repo_info[2]
29	29	------> set -l bare_repo $repo_info[3]
29	29	------> set -l inside_worktree $repo_info[4]
24	24	------> set -q repo_info[5]
29	29	------> set -l sha $repo_info[5]
171	5651	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
120	5480	-------> __fish_git_prompt_operation_branch_bare $repo_info
34	34	--------> set -l git_dir $argv[1]
32	32	--------> set -l inside_gitdir $argv[2]
32	32	--------> set -l bare_repo $argv[3]
24	24	--------> set -q argv[5]
30	30	--------> set -l sha $argv[5]
26	26	--------> set -l branch
26	26	--------> set -l operation
29	29	--------> set -l detached no
25	25	--------> set -l bare
22	22	--------> set -l step
24	24	--------> set -l total
22	22	--------> set -l os
42	231	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
32	32	---------> test -d $git_dir/rebase-merge
17	157	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
30	30	----------> test -d $git_dir/rebase-apply
28	28	----------> test -f $git_dir/MERGE_HEAD
28	28	----------> test -f $git_dir/CHERRY_PICK_HEAD
26	26	----------> test -f $git_dir/REVERT_HEAD
28	28	----------> test -f $git_dir/BISECT_LOG
5	37	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
32	32	---------> test -n "$step" -a -n "$total"
20	4613	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
24	24	---------> test -z "$branch"
175	4532	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4289	4289	----------> command git symbolic-ref HEAD 2>/dev/null
68	68	----------> set os $status
4	37	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
33	33	----------> test $os -ne 0
5	36	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
31	31	---------> test "true" = $inside_gitdir
33	33	--------> echo $operation
31	31	--------> echo $branch
27	27	--------> echo $detached
26	26	--------> echo $bare
34	34	------> set -l r $rbc[1]
30	30	------> set -l b $rbc[2]
30	30	------> set -l detached $rbc[3]
24	24	------> set -l w
23	23	------> set -l i
22	22	------> set -l s
22	22	------> set -l u
29	29	------> set -l c $rbc[4]
23	23	------> set -l p
25	25	------> set -l informative_status
13	17917	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
24	24	-------> not set -q ___fish_git_prompt_init
61	7290	-------> __fish_git_prompt_validate_chars
89	600	--------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
33	33	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	35	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
31	31	----------> set -q $user_variable_name
4	26	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
36	304	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
169	243	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
44	44	-----------> set -q $user_variable_name
30	30	-----------> echo $char
57	615	--------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	106	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
34	78	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
10	272	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
164	236	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
42	42	-----------> set -q $user_variable_name
30	30	-----------> echo $char
57	616	--------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
5	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
33	78	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
10	275	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
166	239	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
42	42	-----------> set -q $user_variable_name
31	31	-----------> echo $char
54	610	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
35	35	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
33	77	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	272	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
162	236	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
43	43	-----------> set -q $user_variable_name
31	31	-----------> echo $char
61	618	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
34	34	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
5	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
33	78	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
32	32	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
9	273	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
163	238	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
44	44	-----------> set -q $user_variable_name
31	31	-----------> echo $char
60	621	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
5	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
34	78	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
32	32	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
10	274	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
163	238	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
44	44	-----------> set -q $user_variable_name
31	31	-----------> echo $char
56	616	--------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
36	36	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
33	77	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
23	23	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
29	29	---------> set -l variable_done "$variable"_done
11	275	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
164	239	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
44	44	-----------> set -q $user_variable_name
31	31	-----------> echo $char
53	613	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
33	77	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
20	20	-----------> set -q __fish_git_prompt_use_informative_chars
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
10	273	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
163	237	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
44	44	-----------> set -q $user_variable_name
30	30	-----------> echo $char
54	634	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
5	105	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
33	78	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	294	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
175	258	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
41	41	-----------> set -q $user_variable_name
42	42	-----------> echo $char
53	565	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
24	24	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
3	26	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
35	306	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
169	245	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
45	45	-----------> set -q $user_variable_name
31	31	-----------> echo $char
55	559	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
36	36	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
3	25	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
22	22	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
29	29	---------> set -l variable_done "$variable"_done
36	300	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
167	239	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
42	42	-----------> set -q $user_variable_name
30	30	-----------> echo $char
56	562	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
34	34	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
3	26	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
36	302	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
25	25	----------> not set -q $variable
170	241	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
41	41	-----------> set -q $user_variable_name
30	30	-----------> echo $char
76	10562	-------> __fish_git_prompt_validate_colors
82	769	--------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
36	36	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
142	345	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
110	110	----------> count $argv
59	59	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	136	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
10	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
56	673	--------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
3	29	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
150	285	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
60	60	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	134	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
26	26	----------> not set -q $variable
11	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
31	31	-----------> set -g $variable_done $default_done
52	666	--------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	29	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
25	25	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
139	283	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
51	51	----------> count $argv
60	60	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
6	135	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
52	665	--------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	29	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
25	25	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
151	285	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
41	41	----------> count $argv
60	60	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
32	32	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
7	133	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
9	99	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
32	32	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
48	646	--------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
32	32	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
28	28	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
134	262	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
52	52	----------> count $argv
46	46	----------> set default $___fish_git_prompt_color
30	30	----------> set default_done $___fish_git_prompt_color_done
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
7	135	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
26	26	----------> not set -q $variable
11	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
25	25	-----------> test -n "$user_variable"
31	31	-----------> set -g $variable $default
35	35	-----------> set -g $variable_done $default_done
55	661	--------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
23	23	---------> set -l user_variable_bright
24	24	---------> set -l default default_done
137	274	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
48	48	----------> count $argv
56	56	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	134	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
12	101	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
32	32	-----------> set -g $variable $default
31	31	-----------> set -g $variable_done $default_done
50	670	--------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
29	29	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
140	283	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
48	48	----------> count $argv
61	61	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	135	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
12	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
31	31	-----------> set -g $variable_done $default_done
53	690	--------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
37	37	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
140	285	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
52	52	----------> count $argv
60	60	----------> set default $___fish_git_prompt_color
33	33	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	146	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	112	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
35	35	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
29	2650	--------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
23	23	---------> set -q __fish_git_prompt_showcolorhints
54	641	---------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
36	36	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
3	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
120	243	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	-----------> count $argv
47	47	-----------> set default $___fish_git_prompt_color
34	34	-----------> set default_done $___fish_git_prompt_color_done
34	34	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	138	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
12	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
59	650	---------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
33	33	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
4	31	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
124	247	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	-----------> count $argv
48	48	-----------> set default $___fish_git_prompt_color
35	35	-----------> set default_done $___fish_git_prompt_color_done
35	35	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	139	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
12	104	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
64	654	---------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
32	32	----------> set -l user_variable_name "$argv[1]"
26	26	----------> set -l user_variable
4	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
120	245	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	-----------> count $argv
47	47	-----------> set default "$argv[2]"
34	34	-----------> set default_done "$argv[3]"
35	35	----------> set -l variable _$user_variable_name
33	33	----------> set -l variable_done "$variable"_done
7	139	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
11	104	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
34	34	------------> set -g $variable $default
33	33	------------> set -g $variable_done $default_done
63	653	---------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
35	35	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
5	31	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
25	25	----------> set -l default default_done
120	245	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	-----------> count $argv
47	47	-----------> set default "$argv[2]"
34	34	-----------> set default_done "$argv[3]"
34	34	----------> set -l variable _$user_variable_name
33	33	----------> set -l variable_done "$variable"_done
8	138	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
10	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
33	33	------------> set -g $variable_done $default_done
151	940	--------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
46	46	---------> set_color red
41	41	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
119	378	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
49	49	----------> set default "$argv[2]"
125	168	----------> set default_done (set_color normal)
43	43	-----------> set_color normal
39	39	---------> set -l variable _$user_variable_name
34	34	---------> set -l variable_done "$variable"_done
7	142	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
29	29	----------> not set -q $variable
10	106	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
35	35	-----------> set -g $variable $default
34	34	-----------> set -g $variable_done $default_done
69	766	--------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
33	33	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	43	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
39	39	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
75	75	---------> set -l default default_done
132	277	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
50	50	----------> count $argv
58	58	----------> set default "$argv[2]"
37	37	----------> set default_done "$argv[3]"
37	37	---------> set -l variable _$user_variable_name
34	34	---------> set -l variable_done "$variable"_done
7	147	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
30	30	----------> not set -q $variable
11	110	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
28	28	-----------> test -n "$user_variable"
36	36	-----------> set -g $variable $default
35	35	-----------> set -g $variable_done $default_done
69	690	--------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
35	35	---------> set -l user_variable_name "$argv[1]"
26	26	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
29	29	---------> set -l user_variable_bright
27	27	---------> set -l default default_done
140	264	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
45	45	----------> count $argv
45	45	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
7	139	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
10	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
34	34	-----------> set -g $variable_done $default_done
28	28	-------> set -g ___fish_git_prompt_init
38	38	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
155	4235	------> set -l informative (command git config --bool bash.showInformativeStatus)
4080	4080	-------> command git config --bool bash.showInformativeStatus
160	4175	------> set -l dirty (command git config --bool bash.showDirtyState)
4015	4015	-------> command git config --bool bash.showDirtyState
11	66	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
30	30	-------> not set -q dirty[1]
25	25	-------> set -q __fish_git_prompt_showdirtystate
156	4158	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
4002	4002	-------> command git config --bool bash.showUntrackedFiles
12	69	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
31	31	-------> not set -q untracked[1]
26	26	-------> set -q __fish_git_prompt_showuntrackedfiles
8	254	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
35	35	-------> test "true" = $inside_worktree
15	159	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
27	27	--------> test "$informative" = true
5	29	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
24	24	---------> set -q __fish_git_prompt_show_informative_status
5	31	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
26	26	---------> test "$dirty" = true
5	27	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
22	22	---------> set -q __fish_git_prompt_showstashstate
3	30	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
27	27	---------> test "$untracked" = true
7	52	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
23	23	--------> set -q __fish_git_prompt_showupstream
22	22	--------> set -q __fish_git_prompt_show_informative_status
35	35	------> set -l branch_color $___fish_git_prompt_color_branch
31	31	------> set -l branch_done $___fish_git_prompt_color_branch_done
4	26	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
22	22	-------> set -q __fish_git_prompt_showcolorhints
4	29	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
25	25	-------> test -n "$w"
4	28	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
24	24	-------> test -n "$i"
3	26	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
23	23	-------> test -n "$s"
3	26	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
23	23	-------> test -n "$u"
150	201	------> set b (string replace refs/heads/ '' -- $b)
51	51	-------> string replace refs/heads/ '' -- $b
29	29	------> set -q __fish_git_prompt_shorten_branch_char_suffix
32	32	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
6	58	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
52	52	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
9	80	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
33	33	-------> test -n "$b"
38	38	-------> set b "$branch_color$b$branch_done"
4	31	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
27	27	-------> test -n "$c"
4	30	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
26	26	-------> test -n "$r"
4	29	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
25	25	-------> test -n "$p"
33	33	------> set -l f "$w$i$s$u"
4	30	------> if test -n "$f"
        set f "$space$f"
    ...
26	26	-------> test -n "$f"
33	33	------> set -l format $argv[1]
3	31	------> if test -z "$format"
        set format " (%s)"
    ...
28	28	-------> test -z "$format"
121	121	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
5	40	---> if test -z $branch_name
    return
  ...
35	35	----> test -z $branch_name
143	187	---> echo -s (set_color normal) " on "
44	44	----> set_color normal
160	7442	---> set -l dirty (command git status --porcelain ^/dev/null)
7282	7282	----> command git status --porcelain ^/dev/null
11	91	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
36	36	----> test -z "$dirty"
44	44	----> set_color --bold red
133	170	---> echo -s "$branch_name" (set_color normal)
37	37	----> set_color normal
167	4780	---> set -l unpushed_changes (git cherry -v ^/dev/null)
4613	4613	----> git cherry -v ^/dev/null
10	68	---> if test -z "$unpushed_changes"
    return
  ...
35	35	----> test -z "$unpushed_changes"
23	23	----> return
45	82	--> _node
5	37	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
32	32	----> test -f ./package.json
46	244	> fish_title
154	198	-> echo (status current-command)
44	44	--> status current-command
68	165	> __fish_disable_bracketed_paste exit
97	97	-> printf "\e[?2004l"
57	303	> fish_title exit
193	246	-> echo (status current-command)
53	53	--> status current-command
135	135	> exit
56	131	> __fish_disable_bracketed_paste 0
75	75	-> printf "\e[?2004l"
