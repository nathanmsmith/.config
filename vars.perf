Time	Sum	Command
1741	8160	> builtin source /usr/local/Cellar/fish/3.1.2/share/fish/config.fish
74	74	-> set -g IFS \n\ \t
28	28	-> set -qg __fish_added_user_paths
28	28	-> set -g __fish_added_user_paths
5	30	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
25	25	--> not set -q __fish_initialized
15	15	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
9	423	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
31	31	--> status --is-interactive
17	383	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
26	26	---> not set -q STY
63	63	---> not string match -q -- 'eterm*' $TERM
21	221	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
26	26	----> set -q KONSOLE_PROFILE_NAME
33	33	----> string match -q -- "*:*" $ITERM_SESSION_ID
34	34	----> string match -q -- "st-*" $TERM
53	53	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
54	54	----> test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit
25	25	---> set -q fish_term24bit
31	31	---> set -g fish_term24bit 1
27	27	-> set -l __extra_completionsdir
25	25	-> set -l __extra_functionsdir
24	24	-> set -l __extra_confdir
11	584	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
60	60	--> test -f $__fish_data_dir/__fish_build_paths.fish
397	513	--> source $__fish_data_dir/__fish_build_paths.fish
57	57	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
31	31	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
28	28	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
30	30	-> set -l xdg_data_dirs
12	71	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
24	24	--> set -q XDG_DATA_DIRS
35	35	--> set xdg_data_dirs $__fish_data_dir
35	35	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
32	32	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
32	32	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
9	88	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
45	45	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
34	34	--> set -a vendor_completionsdirs $__extra_completionsdir
11	75	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
32	32	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
32	32	--> set -a vendor_functionsdirs $__extra_functionsdir
15	145	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
48	48	--> not contains -- $__extra_confdir $vendor_confdirs
82	82	--> set -a vendor_confdirs $__extra_confdir
11	100	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
27	27	--> not set -q fish_function_path
62	62	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
9	97	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
25	25	--> not set -q fish_complete_path
63	63	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
11	11	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
2	66	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
10	64	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
26	26	---> not set -q FISH_UNIT_TESTS_RUNNING
28	28	---> test -d /usr/xpg4/bin
15	15	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
30	30	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
8	8	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
263	1105	-> __fish_set_locale
590	601	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_set_locale.fish
11	11	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
36	36	--> set -l LOCALE_VARS
35	35	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
36	36	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
39	39	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
32	95	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
10	63	---> if set -q $locale_var
            return 0
        ...
29	29	----> set -q $locale_var
24	24	----> return 0
15	15	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
6	49	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
43	43	--> test $__fish_initialized -lt 2300
5	31	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
26	26	--> status --is-login
40	223	-> __fish_reconstruct_path
56	56	--> set -l local_path $PATH
17	17	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
27	27	--> set -g __fish_added_user_paths
5	27	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
22	22	---> set -q fish_user_paths
56	56	--> set -xg PATH $local_path
7	7	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
20	56	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
11	11	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
8	8	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
9	9	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
3	3	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
28	28	-> set -l sourcelist
509	2809	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
117	268	--> set -l basename (string replace -r '^.*/' '' -- $file)
151	151	---> string replace -r '^.*/' '' -- $file
88	88	--> contains -- $basename $sourcelist
35	35	--> set sourcelist $sourcelist $basename
62	62	--> [ -f $file -a -r $file ]
298	460	--> source $file
41	41	---> set -q FZF_TMUX_HEIGHT
25	25	---> set -q FZF_DEFAULT_OPTS
22	22	---> set -q FZF_LEGACY_KEYBINDINGS
22	22	---> set -q FZF_DISABLE_KEYBINDINGS
22	22	---> set -q FZF_PREVIEW_FILE_CMD
21	21	---> set -q FZF_PREVIEW_DIR_CMD
9	9	---> function fzf_uninstall -e fzf_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _vars (set | command grep -E "^FZF.*\$" | command awk '{print $1;}')
    # for var in $_vars
    #     eval (set -e $var)
    # end
...
109	165	--> set -l basename (string replace -r '^.*/' '' -- $file)
56	56	---> string replace -r '^.*/' '' -- $file
46	46	--> contains -- $basename $sourcelist
35	35	--> set sourcelist $sourcelist $basename
63	63	--> [ -f $file -a -r $file ]
393	1078	--> source $file
11	674	---> if test "$FZF_DISABLE_KEYBINDINGS" -ne 1
    if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    end

    if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    end
...
46	46	----> test "$FZF_DISABLE_KEYBINDINGS" -ne 1
23	587	----> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    ...
34	34	-----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
86	86	-----> bind \ct '__fzf_find_file'
32	32	-----> bind \cr '__fzf_reverse_isearch'
29	29	-----> bind \ec '__fzf_cd'
29	29	-----> bind \eC '__fzf_cd --hidden'
29	29	-----> bind \cg '__fzf_open'
29	29	-----> bind \co '__fzf_open --editor'
24	296	-----> if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        ...
89	89	------> bind -M insert >/dev/null 2>/dev/null
34	34	------> bind -M insert \ct '__fzf_find_file'
31	31	------> bind -M insert \cr '__fzf_reverse_isearch'
30	30	------> bind -M insert \ec '__fzf_cd'
30	30	------> bind -M insert \eC '__fzf_cd --hidden'
29	29	------> bind -M insert \cg '__fzf_open'
29	29	------> bind -M insert \co '__fzf_open --editor'
6	30	----> if set -q FZF_COMPLETE
        bind \t '__fzf_complete'
        if bind -M insert >/dev/null 2>/dev/null
            bind -M insert \t '__fzf_complete'
        end
    ...
24	24	-----> set -q FZF_COMPLETE
11	11	---> function fzf_key_bindings_uninstall -e fzf_key_bindings_uninstall
    # disabled until we figure out a sensible way to ensure user overrides
    # are not erased
    # set -l _bindings (bind -a | sed -En "s/(')?__fzf.*\$//p" | sed 's/bind/bind -e/')
    # for binding in $_bindings
    #     eval $binding
    # end
...
215	215	> builtin source /usr/local/Cellar/fish/3.1.2/etc/fish/config.fish
312	352	> builtin source /Users/nathan/.config/fish/config.fish
9	40	-> if status --is-login
  set -gx fish_greeting ""

  switch (uname)
  case Linux
      echo Hi Tux!
      set -gx HOMEBREW_PREFIX "/home/linuxbrew/.linuxbrew";
      set -gx HOMEBREW_CELLAR "/home/linuxbrew/.linuxbrew/Cellar";
      set -gx HOMEBREW_REPOSITORY "/home/linuxbrew/.linuxbrew/Homebrew";
      set -g fish_user_paths "/home/linuxbrew/.linuxbrew/bin" "/home/linuxbrew/.linuxbrew/sbin" $fish_user_paths;
      set -q MANPATH; or set MANPATH ''; set -gx MANPATH "/home/linuxbrew/.linuxbrew/share/man" $MANPATH;
      set -q INFOPATH; or set INFOPATH ''; set -gx INFOPATH "/home/linuxbrew/.linuxbrew/share/info" $INFOPATH;
  case Darwin
      # set -gx PATH /usr/local/bin /usr/bin /bin /usr/sbin /sbin /usr/local/sbin /usr/local/MacGPG2/bin /Library/TeX/texbin
      # Use GNU utilities instead of macOS versions
      set -gx PATH /usr/local/opt/{coreutils,findutils,grep,gnu-sed,gnu-time,make,gnu-units}/libexec/gnubin $PATH
      # Use Homebrew curl
      set -gx PATH /usr/local/opt/curl/bin $PATH
      # Use installed LLVM tools
      set -gx PATH /usr/local/opt/llvm/bin $PATH
  case '*'
      echo Unknown OS, you may want to add some config!
      uname
  end


  # XDG Directories
  set -gx XDG_CONFIG_HOME $HOME/.config
  # set -gx XDG_CACHE_HOME $HOME/.cache
  # set -gx XDG_DATA_HOME $HOME/.local/share

  # Bootstrap fisher
  # https://github.com/jorgebucaran/fisher
  # if not functions -q fisher
  #     curl https://git.io/fisher --create-dirs -sLo "$XDG_CONFIG_HOME/fish/functions/fisher.fish"
  #     fish -c fisher
  # end

  # Set editor
  set -gx EDITOR nvim

  # FZF
  set -gx FZF_DEFAULT_COMMAND  'rg -g !.git/ --files --hidden'

  # AWS
  set -gx SAM_CLI_TELEMETRY 0

  # Load aliases
  source ~/.config/fish/aliases.fish

  # Load secrets
  # source ~/.config/fish/secrets.fish

  # Force certain more-secure behaviors from homebrew
  set -x HOMEBREW_NO_INSECURE_REDIRECT 1
  set -x HOMEBREW_CASK_OPTS --require-sha
  set -gx HOMEBREW_NO_ANALYTICS 1

  # JavaScript specific settings
  # Set up nodenv
  # if type --no-function --quiet nodenv
  #   status --is-interactive; and nodenv init - | source
  # end

  # Ruby specific settings
  # Rbenv
  # if type --no-function --quiet rbenv
  #   status --is-interactive; and rbenv init - | source
  # end
  set -gx PATH /usr/local/lib/ruby/gems/2.7.0/bin /usr/local/opt/ruby/bin $PATH

  # Go specific settings
  set -gx GOPATH ~/Developer/go
  set -gx PATH $GOPATH/bin $PATH

  # Python settings
  set -gx PATH $HOME/.poetry/bin $PATH
  set -gx PATH /usr/local/opt/python@3.8/bin $PATH
  # if type --no-function --quiet pyenv
  #   status --is-interactive; and pyenv init - | source
  # end
  # Use pyenv's current python version
  set -gx PIPENV_PYTHON /usr/local/opt/python@3.8/bin/python3

  # PySpark
  set -gx PYSPARK_PYTHON /usr/local/opt/python/libexec/bin/python


  # Rust specific settings
  # Rust tools XDG compatibility
  # set -gx CARGO_HOME "$XDG_DATA_HOME"/cargo
  # set -gx RUSTUP_HOME "$XDG_DATA_HOME"/rustup

  # set -gx PATH $PATH $CARGO_HOME/bin

  # Io specific settings
  # set -gx EERIEDIR ~/.eerie
  # set -gx PATH $PATH $EERIEDIR/base/bin $EERIEDIR/activeEnv/bin

#   # Keybase development
#   set -e KEYBASE_PERF
#   set -x KEYBASE_LOCAL_DEBUG 1
#   set -x KEYBASE_DEV_TOOL_ROOTS "$HOME/Library/Application Support/Google/Chrome/Default/Extensions/fmkadmapgofadopljbjfkapdkoienihi,$HOME/Library/Application Support/Google/Chrome/Default/Extensions/hgldghadipiblonfkkicmgcbbijnpeog"
#   set -x RUN_MODE devel
#   # set -gx PATH /usr/local/opt/mysql@5.6/bin $PATH
#   # Android
#   # set -x ANDROID_HOME "$HOME/Library/Android/sdk"
#   # set -x PATH $PATH $ANDROID_HOME/tools $ANDROID_HOME/platform-tools $ANDROID_HOME/tools/bin $ANDROID_HOME/emulator
...
31	31	--> status --is-login
245	256	> source /Users/nathan/.config/fish/functions/fish_title.fish
11	11	-> function fish_title
  echo (status current-command)
...
50	254	> fish_title
166	204	-> echo (status current-command)
38	38	--> status current-command
484	532	> source /Users/nathan/.config/fish/functions/fish_prompt.fish
15	15	-> function _user_host_name -d "Displays the user and host name if connected via SSH"
  if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  end
...
9	9	-> function _directory -d "Writes the colorized present working directory"
  echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
...
8	8	-> function _node -d "Writes the node version if there is a package.json"
  if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  end
...
8	8	-> function _git_status -d "Writes the current git status, if there is one."
  set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
  if test -z $branch_name
    return
  end

  echo -s (set_color normal) " on "
  set -l dirty (command git status --porcelain ^/dev/null)
  if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  end
  echo -s "$branch_name" (set_color normal)

  set -l unpushed_changes (git cherry -v ^/dev/null)
  if test -z "$unpushed_changes"
    return
  end

  echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)

...
8	8	-> function fish_prompt -d "Write out the prompt"
  echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
...
39	18541	> __fish_on_interactive
221	18468	-> __fish_config_interactive
1636	1650	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_config_interactive.fish
14	14	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
4	40	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
36	36	---> test $__fish_initialized -lt 3000
4	29	--> if set -q __fish_config_interactive_done
        return
    ...
25	25	---> set -q __fish_config_interactive_done
26	26	--> set -g __fish_config_interactive_done
24	24	--> set -g __fish_active_key_bindings
3	25	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
22	22	---> not set -q fish_greeting
2	24	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
22	22	---> set -q fish_private_mode
10	10	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
3	30	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
27	27	---> test $__fish_initialized -lt 3100
14	87	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
23	23	---> not set -q FISH_UNIT_TESTS_RUNNING
2	50	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
48	48	----> not test -d $__fish_user_data_dir/generated_completions
5	242	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
27	27	---> status --is-interactive
10	210	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
114	114	----> functions -q fish_greeting
32	32	----> test -n "$fish_greeting"
54	54	----> echo $fish_greeting
34	34	--> set -l varargs --on-variable fish_key_bindings
37	209	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
34	34	---> set -a varargs --on-variable fish_color_$var
33	33	---> set -a varargs --on-variable fish_color_$var
33	33	---> set -a varargs --on-variable fish_color_$var
37	37	---> set -a varargs --on-variable fish_color_$var
35	35	---> set -a varargs --on-variable fish_color_$var
38	38	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
4	41	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
37	37	---> test -d /etc/init.d
81	81	--> complete -c [ --wraps test
31	31	--> complete -c ! --wraps not
246	445	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
199	199	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
18	18	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
50	9687	--> __fish_reload_key_bindings
37	85	---> __init_uvar fish_key_bindings fish_default_key_bindings
4	48	----> if not set --query $argv[1]
            set --universal $argv
        ...
44	44	-----> not set --query $argv[1]
3	48	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
45	45	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
4	1006	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
163	1002	----> not functions -q "$fish_key_bindings"
824	839	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_key_bindings.fish
15	15	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
61	61	---> set -g __fish_active_key_bindings "$fish_key_bindings"
32	32	---> set -g fish_bind_mode default
7	7960	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
37	37	----> test "$fish_key_bindings" = fish_default_key_bindings
170	7916	----> fish_default_key_bindings 2>/dev/null
6	77	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
39	39	------> contains -- -h $argv
32	32	------> contains -- --help $argv
8	121	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
27	27	------> not set -q argv[1]
49	49	------> bind --erase --all --preset
3	37	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
34	34	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
8	71	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
31	31	------> not contains -- -s $argv
32	32	------> set argv "-s" $argv
408	5886	-----> __fish_shared_key_bindings $argv
1230	1264	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_shared_key_bindings.fish
15	15	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
11	11	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
4	4	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
4	4	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
8	80	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
40	40	-------> contains -- -h $argv
32	32	-------> contains -- --help $argv
37	37	------> bind --preset $argv \cy yank
34	34	------> bind --preset $argv \ey yank-pop
43	43	------> bind --preset $argv -k right forward-char
35	35	------> bind --preset $argv -k left backward-char
33	33	------> bind --preset $argv \e\[C forward-char
33	33	------> bind --preset $argv \e\[D backward-char
32	32	------> bind --preset $argv \eOC forward-char
31	31	------> bind --preset $argv \eOD backward-char
33	33	------> bind --preset $argv -k ppage beginning-of-history
33	33	------> bind --preset $argv -k npage end-of-history
38	38	------> bind --preset $argv \cx fish_clipboard_copy
34	34	------> bind --preset $argv \cv fish_clipboard_paste
32	32	------> bind --preset $argv \e cancel
31	31	------> bind --preset $argv \t complete
36	36	------> bind --preset $argv \cs pager-toggle-search
34	34	------> bind --preset $argv --key btab complete-and-search
35	35	------> bind --preset $argv \e\n "commandline -i \n"
35	35	------> bind --preset $argv \e\r "commandline -i \n"
37	37	------> bind --preset $argv -k down down-or-search
40	40	------> bind --preset $argv -k up up-or-search
37	37	------> bind --preset $argv \e\[A up-or-search
36	36	------> bind --preset $argv \e\[B down-or-search
34	34	------> bind --preset $argv \eOA up-or-search
33	33	------> bind --preset $argv \eOB down-or-search
37	37	------> bind --preset $argv -k sright forward-bigword
38	38	------> bind --preset $argv -k sleft backward-bigword
40	40	------> bind --preset $argv \e\eOC nextd-or-forward-word
35	35	------> bind --preset $argv \e\eOD prevd-or-backward-word
36	36	------> bind --preset $argv \e\e\[C nextd-or-forward-word
36	36	------> bind --preset $argv \e\e\[D prevd-or-backward-word
36	36	------> bind --preset $argv \eO3C nextd-or-forward-word
37	37	------> bind --preset $argv \eO3D prevd-or-backward-word
36	36	------> bind --preset $argv \e\[3C nextd-or-forward-word
39	39	------> bind --preset $argv \e\[3D prevd-or-backward-word
39	39	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
42	42	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
40	40	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
35	35	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
33	33	------> bind --preset $argv \e\eOA history-token-search-backward
33	33	------> bind --preset $argv \e\eOB history-token-search-forward
33	33	------> bind --preset $argv \e\e\[A history-token-search-backward
33	33	------> bind --preset $argv \e\e\[B history-token-search-forward
33	33	------> bind --preset $argv \eO3A history-token-search-backward
33	33	------> bind --preset $argv \eO3B history-token-search-forward
46	46	------> bind --preset $argv \e\[3A history-token-search-backward
33	33	------> bind --preset $argv \e\[3B history-token-search-forward
34	34	------> bind --preset $argv \e\[1\;3A history-token-search-backward
33	33	------> bind --preset $argv \e\[1\;3B history-token-search-forward
34	34	------> bind --preset $argv \e\[1\;9A history-token-search-backward
33	33	------> bind --preset $argv \e\[1\;9B history-token-search-forward
32	32	------> bind --preset $argv \e. history-token-search-backward
33	33	------> bind --preset $argv \el __fish_list_current_token
35	35	------> bind --preset $argv \ew __fish_whatis_current_token
37	37	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
33	33	------> bind --preset $argv \cc __fish_cancel_commandline
32	32	------> bind --preset $argv \cu backward-kill-line
32	32	------> bind --preset $argv \cw backward-kill-path-component
34	34	------> bind --preset $argv \e\[F end-of-line
49	49	------> bind --preset $argv \e\[H beginning-of-line
46	46	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
56	56	------> bind --preset $argv \cd delete-or-exit
39	39	------> bind --preset $argv \es __fish_prepend_sudo
43	43	------> bind --preset $argv -k f1 __fish_man_page
43	43	------> bind --preset $argv \eh __fish_man_page
43	43	------> bind --preset $argv \ep '__fish_paginate'
41	41	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
42	42	------> bind --preset $argv \ee edit_command_buffer
36	36	------> bind --preset $argv \ev edit_command_buffer
188	867	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
363	363	-------> bind --list-modes | string match -v paste
99	99	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
48	48	-------> bind --preset -M $mode \e\[O false
41	41	-------> bind --preset -M $mode \e\[\?1004h false
45	45	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
39	39	-------> bind --preset -M $mode \e\[O false
44	44	-------> bind --preset -M $mode \e\[\?1004h false
132	546	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
277	277	-------> bind --list-modes | string match -v paste
88	88	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
49	49	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
44	44	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
41	41	------> bind --preset -M paste "" self-insert
41	41	------> bind --preset -M paste \r "commandline -i \n"
40	40	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
40	40	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
36	36	------> bind --preset -M paste " " self-insert-notfirst
41	41	-----> bind --preset $argv "" self-insert
47	47	-----> bind --preset $argv " " self-insert expand-abbr
43	43	-----> bind --preset $argv \n execute
37	37	-----> bind --preset $argv \r execute
38	38	-----> bind --preset $argv \ck kill-line
38	38	-----> bind --preset $argv \eOC forward-char
37	37	-----> bind --preset $argv \eOD backward-char
38	38	-----> bind --preset $argv \e\[C forward-char
41	41	-----> bind --preset $argv \e\[D backward-char
43	43	-----> bind --preset $argv -k right forward-char
40	40	-----> bind --preset $argv -k left backward-char
48	48	-----> bind --preset $argv -k dc delete-char
48	48	-----> bind --preset $argv -k backspace backward-delete-char
40	40	-----> bind --preset $argv \x7f backward-delete-char
33	33	-----> bind --preset $argv \e\[1~ beginning-of-line
31	31	-----> bind --preset $argv \e\[3~ delete-char
32	32	-----> bind --preset $argv \e\[4~ end-of-line
74	74	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
53	53	-----> bind --preset $argv -k end end-of-line 2>/dev/null
36	36	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
31	31	-----> bind --preset $argv \ca beginning-of-line
31	31	-----> bind --preset $argv \ce end-of-line
31	31	-----> bind --preset $argv \ch backward-delete-char
34	34	-----> bind --preset $argv \cp up-or-search
31	31	-----> bind --preset $argv \cn down-or-search
57	57	-----> bind --preset $argv \cf forward-char
50	50	-----> bind --preset $argv \cb backward-char
34	34	-----> bind --preset $argv \ct transpose-chars
32	32	-----> bind --preset $argv \et transpose-words
66	66	-----> bind --preset $argv \eu upcase-word
44	44	-----> bind --preset $argv \ec capitalize-word
36	36	-----> bind --preset $argv \e\x7f backward-kill-word
32	32	-----> bind --preset $argv \e\b backward-kill-word
32	32	-----> bind --preset $argv \eb backward-word
31	31	-----> bind --preset $argv \ef forward-word
34	34	-----> bind --preset $argv \e\[1\;5C forward-word
34	34	-----> bind --preset $argv \e\[1\;5D backward-word
32	32	-----> bind --preset $argv \e\< beginning-of-buffer
32	32	-----> bind --preset $argv \e\> end-of-buffer
31	31	-----> bind --preset $argv \ed kill-word
18	18	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
5	445	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
152	440	----> functions --query fish_user_key_bindings >/dev/null
288	288	-----> source /Users/nathan/.config/fish/functions/fish_user_key_bindings.fish
11	239	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
41	41	---> not set -q FISH_UNIT_TESTS_RUNNING
11	11	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
11	11	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
33	165	---> __fish_enable_bracketed_paste
132	132	----> printf "\e[?2004h"
5	37	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
32	32	---> set -q TMUX
17	17	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
5	244	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
135	239	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
104	104	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
19	4894	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
216	2146	---> not type -q __fish_command_not_found_handler
660	672	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/type.fish
12	12	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
31	31	----> set -q argv[1]
50	50	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
75	75	----> argparse -n type -x t,p,P $options -- $argv
3	30	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	-----> set -q _flag_help
26	26	----> set -l res 1
24	24	----> set -l mode normal
25	25	----> set -l multi no
24	24	----> set -l selection all
24	24	----> set -l short no
6	53	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	-----> set -q _flag_quiet
25	25	-----> set mode quiet
22	22	----> set -q _flag_all
21	21	----> set -q _flag_short
21	21	----> set -q _flag_no_functions
28	805	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	-----> set -l found 0
12	358	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	------> test $selection != files
3	85	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
82	82	-------> functions -q -- $i
4	233	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
176	229	-------> contains -- $i (builtin -n)
53	53	--------> builtin -n
31	31	-----> set -l paths
10	287	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
38	38	------> test $multi != yes
96	239	------> set paths (command -s -- $i)
143	143	-------> command -s -- $i
12	12	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	64	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	------> test $found = 0
27	27	------> test $mode != quiet
27	27	----> return $res
25	25	---> set -l os
3	40	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
37	37	----> test -r /etc/os-release
18	2664	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
33	33	----> contains -- suse $os
26	26	----> contains -- sles $os
28	28	----> test -f /usr/libexec/pk-command-not-found
26	26	----> test -f /usr/lib/command-not-found
24	24	----> test -f /run/current-system/sw/bin/command-not-found
75	1242	----> type -q command-not-found
23	23	-----> set -q argv[1]
44	44	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
62	62	-----> argparse -n type -x t,p,P $options -- $argv
3	26	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
23	23	------> set -q _flag_help
24	24	-----> set -l res 1
23	23	-----> set -l mode normal
24	24	-----> set -l multi no
24	24	-----> set -l selection all
23	23	-----> set -l short no
6	51	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
21	21	------> set -q _flag_quiet
24	24	------> set mode quiet
21	21	-----> set -q _flag_all
20	20	-----> set -q _flag_short
21	21	-----> set -q _flag_no_functions
28	754	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	------> set -l found 0
13	332	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
26	26	-------> test $selection != files
3	83	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
80	80	--------> functions -q -- $i
4	210	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
157	206	--------> contains -- $i (builtin -n)
49	49	---------> builtin -n
28	28	------> set -l paths
9	266	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
27	27	-------> test $multi != yes
96	230	-------> set paths (command -s -- $i)
134	134	--------> command -s -- $i
12	12	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
4	63	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	-------> test $found = 0
28	28	-------> test $mode != quiet
27	27	-----> return $res
76	1257	----> type -p -q pkgfile
24	24	-----> set -q argv[1]
48	48	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-----> argparse -n type -x t,p,P $options -- $argv
3	26	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
23	23	------> set -q _flag_help
27	27	-----> set -l res 1
25	25	-----> set -l mode normal
24	24	-----> set -l multi no
24	24	-----> set -l selection all
23	23	-----> set -l short no
7	51	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
21	21	------> set -q _flag_quiet
23	23	------> set mode quiet
22	22	-----> set -q _flag_all
21	21	-----> set -q _flag_short
21	21	-----> set -q _flag_no_functions
26	750	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
25	25	------> set -l found 0
14	350	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	-------> test $selection != files
2	80	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
78	78	--------> functions -q -- $i
4	226	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
173	222	--------> contains -- $i (builtin -n)
49	49	---------> builtin -n
31	31	------> set -l paths
9	240	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	-------> test $multi != yes
97	203	-------> set paths (command -s -- $i)
106	106	--------> command -s -- $i
14	14	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
7	64	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	-------> test $found = 0
27	27	-------> test $mode != quiet
27	27	-----> return $res
10	10	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
45	45	--> set __fish_initialized 3100
34	34	-> functions -e __fish_on_interactive
310	325	> source /Users/nathan/.config/fish/functions/fish_mode_prompt.fish
15	15	-> function fish_mode_prompt --description 'Displays the current mode'
  # This is a function override, we handle displaying the mode in the prompt directly in `fish_prompt.fish`
  # See https://github.com/fish-shell/fish-shell/issues/3232#issuecomment-232670506
...
48	48	> fish_mode_prompt
56	72495	> fish_prompt
388	72439	-> echo -nes "\n" (_user_host_name) (_directory) (_git_status) (_node) '\n› '
33	74	--> _user_host_name
6	41	---> if test -n "$SSH_TTY"
    switch "$USER"
      case root toor
        set user_color red
      case '*'
        set user_color yellow
    end
    echo -s (set_color --bold $user_color) $USER (set_color normal) ' at ' (set_color --bold blue) (prompt_hostname) (set_color normal) ' '
  ...
35	35	----> test -n "$SSH_TTY"
48	1695	--> _directory
313	1647	---> echo -s 'in ' (set_color --bold cyan) (prompt_pwd) (set_color normal)
113	113	----> set_color --bold cyan
203	1173	----> prompt_pwd
398	412	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/prompt_pwd.fish
14	14	------> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
37	37	-----> set -l options 'h/help'
39	39	-----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	-----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	------> set -q _flag_help
24	24	-----> set -q fish_prompt_pwd_dir_length
27	27	-----> set -l fish_prompt_pwd_dir_length 1
40	40	-----> set realhome ~
175	250	-----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
75	75	------> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
20	112	-----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	------> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	------> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
48	48	----> set_color normal
77	70201	--> _git_status
164	52795	---> set -l branch_name (__fish_git_prompt "%s" | sed 's/ //')
1001	52631	----> __fish_git_prompt "%s" | sed 's/ //'
270	278	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_git_prompt.fish
8	8	------> function __fish_git_prompt
    # TODO: This name is deprecated, figure out a way to tell users.
    fish_git_prompt $argv
...
384	51352	-----> fish_git_prompt $argv
4239	6278	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_git_prompt.fish
20	20	-------> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null | string replace \t " ")

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end

    # For the return status
    test "$count" = "0 0"
...
9	9	-------> function fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    # Use our variables as defaults, but allow overrides via the local git config.
    # That means if neither is set, this stays empty.
    #
    # So "!= true" or "!= false" are useful tests if you want to do something by default.
    set -l informative (command git config --bool bash.showInformativeStatus)

    set -l dirty (command git config --bool bash.showDirtyState)
    if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    end

    set -l untracked (command git config --bool bash.showUntrackedFiles)
    if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    end

    if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
10	10	-------> function __fish_git_prompt_staged --description "fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]
    set -l staged
    set -l ret 0

    if test -n "$sha"
        # The "diff" functions all return > 0 if there _is_ a diff,
        # but we want to return 0 if there are staged changes.
        # So we invert the status.
        not command git diff-index --cached --quiet HEAD -- 2>/dev/null
        and set staged $___fish_git_prompt_char_stagedstate
        set ret $status
    else
        set staged $___fish_git_prompt_char_invalidstate
        set ret 2
    end
    echo $staged
    return $ret
...
9	9	-------> function __fish_git_prompt_untracked --description "fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l ret 1
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set ret $status
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
    return $ret
...
8	8	-------> function __fish_git_prompt_dirty --description "fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    # Like staged, invert the status because we want 0 to mean there are dirty files.
    not command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set -l os $status
    if test $os -eq 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
    return $os
...
53	53	-------> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
5	32	-------> if set -q __fish_git_prompt_showstashstate
    set -a ___fish_git_prompt_status_order stashstate
...
27	27	--------> set -q __fish_git_prompt_showstashstate
5	5	-------> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | count)
    set -l stashstate 0
    set -l stashfile "$argv[1]/logs/refs/stash"
    if set -q __fish_git_prompt_showstashstate; and test -e "$stashfile"
        set stashstate (count < $stashfile)
    end

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles + $stashstate 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
10	10	-------> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
4	4	-------> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
9	9	-------> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
4	4	-------> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
11	11	-------> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
29	29	-------> set -l varargs
82	367	-------> for var in repaint describe_style show_informative_status use_informative_chars showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
35	35	--------> set -a varargs --on-variable __fish_git_prompt_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_$var
39	39	--------> set -a varargs --on-variable __fish_git_prompt_$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_$var
43	43	-------> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
            # Clear init so we reset the chars next time.
            set -e ___fish_git_prompt_init
        end

        commandline -f repaint 2>/dev/null
    end
...
28	28	-------> set -l varargs
87	652	-------> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
31	31	--------> set -a varargs --on-variable __fish_git_prompt_color$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_color$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_color$var
35	35	--------> set -a varargs --on-variable __fish_git_prompt_color$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_color$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_color$var
38	38	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
40	40	--------> set -a varargs --on-variable __fish_git_prompt_color$var
41	41	--------> set -a varargs --on-variable __fish_git_prompt_color$var
42	42	--------> set -a varargs --on-variable __fish_git_prompt_color$var
46	46	--------> set -a varargs --on-variable __fish_git_prompt_color$var
44	44	--------> set -a varargs --on-variable __fish_git_prompt_color$var
43	43	-------> set -a varargs --on-variable __fish_git_prompt_showcolorhints
67	67	-------> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
30	30	-------> set -l varargs
73	538	-------> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
32	32	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
33	33	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
34	34	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
36	36	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
37	37	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
44	44	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
60	60	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
44	44	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
43	43	--------> set -a varargs --on-variable __fish_git_prompt_char_$var
58	58	-------> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
6	81	------> if not command -sq git
        return 1
    ...
75	75	-------> not command -sq git
169	4618	------> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
4449	4449	-------> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
36	36	------> test -n "$repo_info"
33	33	------> set -l git_dir $repo_info[1]
31	31	------> set -l inside_gitdir $repo_info[2]
34	34	------> set -l bare_repo $repo_info[3]
30	30	------> set -l inside_worktree $repo_info[4]
25	25	------> set -q repo_info[5]
31	31	------> set -l sha $repo_info[5]
172	5885	------> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
145	5713	-------> __fish_git_prompt_operation_branch_bare $repo_info
38	38	--------> set -l git_dir $argv[1]
36	36	--------> set -l inside_gitdir $argv[2]
32	32	--------> set -l bare_repo $argv[3]
27	27	--------> set -q argv[5]
33	33	--------> set -l sha $argv[5]
28	28	--------> set -l branch
27	27	--------> set -l operation
27	27	--------> set -l detached no
26	26	--------> set -l bare
25	25	--------> set -l step
26	26	--------> set -l total
26	26	--------> set -l os
41	271	--------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
36	36	---------> test -d $git_dir/rebase-merge
20	194	---------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
39	39	----------> test -d $git_dir/rebase-apply
36	36	----------> test -f $git_dir/MERGE_HEAD
33	33	----------> test -f $git_dir/CHERRY_PICK_HEAD
34	34	----------> test -f $git_dir/REVERT_HEAD
32	32	----------> test -f $git_dir/BISECT_LOG
5	43	--------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
38	38	---------> test -n "$step" -a -n "$total"
17	4736	--------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
31	31	---------> test -z "$branch"
153	4648	---------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
4436	4436	----------> command git symbolic-ref HEAD 2>/dev/null
59	59	----------> set os $status
5	40	---------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
35	35	----------> test $os -ne 0
5	37	--------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
32	32	---------> test "true" = $inside_gitdir
35	35	--------> echo $operation
39	39	--------> echo $branch
29	29	--------> echo $detached
27	27	--------> echo $bare
35	35	------> set -l r $rbc[1]
31	31	------> set -l b $rbc[2]
30	30	------> set -l detached $rbc[3]
24	24	------> set -l w
24	24	------> set -l i
23	23	------> set -l s
23	23	------> set -l u
27	27	------> set -l c $rbc[4]
23	23	------> set -l p
25	25	------> set -l informative_status
16	17271	------> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
25	25	-------> not set -q ___fish_git_prompt_init
64	7029	-------> __fish_git_prompt_validate_chars
94	572	--------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
34	34	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
37	273	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
145	210	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
32	32	-----------> echo $char
57	590	--------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	109	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
33	80	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
25	25	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
11	238	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
134	201	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
36	36	-----------> set -q $user_variable_name
31	31	-----------> echo $char
61	604	--------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
42	42	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
5	111	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
24	24	----------> set -q argv[3]
36	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
32	32	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
12	238	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
133	200	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
35	35	-----------> set -q $user_variable_name
32	32	-----------> echo $char
58	601	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	118	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
37	89	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
30	30	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
32	32	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
11	241	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
139	204	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
32	32	-----------> echo $char
59	595	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	110	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
24	24	----------> set -q argv[3]
37	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
21	21	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
9	242	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
134	206	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
40	40	-----------> set -q $user_variable_name
32	32	-----------> echo $char
57	593	--------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
6	111	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
36	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
11	240	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
139	203	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
32	32	-----------> set -q $user_variable_name
32	32	-----------> echo $char
58	590	--------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
35	35	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
6	111	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
36	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
31	31	---------> set -l variable _$user_variable_name
30	30	---------> set -l variable_done "$variable"_done
11	238	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
136	201	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
32	32	-----------> echo $char
62	605	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
36	36	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
6	111	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
36	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
9	246	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
141	210	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
36	36	-----------> echo $char
62	599	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
35	35	---------> set -l user_variable_name "$argv[1]"
29	29	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
5	110	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
36	82	----------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
24	24	-----------> set -q __fish_git_prompt_show_informative_status
22	22	-----------> set -q __fish_git_prompt_use_informative_chars
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
9	241	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
137	205	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
33	33	-----------> set -q $user_variable_name
35	35	-----------> echo $char
54	548	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
33	33	---------> set -l user_variable_name "$argv[1]"
28	28	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
32	288	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
149	229	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
45	45	-----------> set -q $user_variable_name
35	35	-----------> echo $char
59	534	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
26	26	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
30	30	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
35	263	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
26	26	----------> not set -q $variable
133	202	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
36	36	-----------> set -q $user_variable_name
33	33	-----------> echo $char
57	534	--------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
36	36	---------> set -l user_variable_name "$argv[1]"
30	30	---------> set -l char $argv[2]
25	25	---------> set -l user_variable
5	32	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
4	27	---------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
23	23	----------> set -q argv[3]
31	31	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
37	265	---------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
27	27	----------> not set -q $variable
136	201	----------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
34	34	-----------> set -q $user_variable_name
31	31	-----------> echo $char
61	10173	-------> __fish_git_prompt_validate_colors
93	753	--------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
36	36	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
26	26	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
121	307	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
104	104	----------> count $argv
47	47	----------> set default "$argv[2]"
35	35	----------> set default_done "$argv[3]"
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	139	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	105	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
28	28	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
56	638	--------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
31	31	---------> set -l user_variable_name "$argv[1]"
24	24	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
119	243	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	----------> count $argv
49	49	----------> set default $___fish_git_prompt_color
35	35	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	139	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
12	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
54	643	--------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
38	38	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
117	242	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	137	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
54	647	--------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
37	37	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
5	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
118	247	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
43	43	----------> count $argv
52	52	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	137	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
59	650	--------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
121	248	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
51	51	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
35	35	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
56	627	--------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
117	232	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
46	46	----------> count $argv
38	38	----------> set default $___fish_git_prompt_color
31	31	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
31	31	---------> set -l variable_done "$variable"_done
8	137	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
11	102	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
53	626	--------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
31	31	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
113	233	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
39	39	----------> count $argv
47	47	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
34	34	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
10	103	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
55	635	--------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	31	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	----------> set -q $user_variable_name
24	24	---------> set -l user_variable_bright
25	25	---------> set -l default default_done
116	240	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
48	48	----------> set default $___fish_git_prompt_color
34	34	----------> set default_done $___fish_git_prompt_color_done
33	33	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	----------> not set -q $variable
12	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
18	2641	--------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
24	24	---------> set -q __fish_git_prompt_showcolorhints
57	642	---------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
32	32	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
5	36	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
31	31	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
26	26	----------> set -l default default_done
116	239	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
40	40	-----------> count $argv
48	48	-----------> set default $___fish_git_prompt_color
35	35	-----------> set default_done $___fish_git_prompt_color_done
34	34	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	136	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
27	27	-----------> not set -q $variable
11	102	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
52	650	---------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
32	32	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
15	42	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
27	27	-----------> set -q $user_variable_name
26	26	----------> set -l user_variable_bright
27	27	----------> set -l default default_done
118	243	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
39	39	-----------> count $argv
52	52	-----------> set default $___fish_git_prompt_color
34	34	-----------> set default_done $___fish_git_prompt_color_done
33	33	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	138	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
10	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
33	33	------------> set -g $variable_done $default_done
69	655	---------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
33	33	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
5	31	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
24	24	----------> set -l user_variable_bright
26	26	----------> set -l default default_done
119	243	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	-----------> count $argv
47	47	-----------> set default "$argv[2]"
33	33	-----------> set default_done "$argv[3]"
35	35	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	137	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
10	102	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
32	32	------------> set -g $variable_done $default_done
60	652	---------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
36	36	----------> set -l user_variable_name "$argv[1]"
25	25	----------> set -l user_variable
4	30	----------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	-----------> set -q $user_variable_name
25	25	----------> set -l user_variable_bright
26	26	----------> set -l default default_done
119	247	----------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
44	44	-----------> count $argv
50	50	-----------> set default "$argv[2]"
34	34	-----------> set default_done "$argv[3]"
33	33	----------> set -l variable _$user_variable_name
32	32	----------> set -l variable_done "$variable"_done
7	138	----------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	-----------> not set -q $variable
11	103	-----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
26	26	------------> test -n "$user_variable"
33	33	------------> set -g $variable $default
33	33	------------> set -g $variable_done $default_done
150	940	--------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
47	47	---------> set_color red
40	40	---------> set -l user_variable_name "$argv[1]"
27	27	---------> set -l user_variable
5	33	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
28	28	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
121	381	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
45	45	----------> count $argv
49	49	----------> set default "$argv[2]"
125	166	----------> set default_done (set_color normal)
41	41	-----------> set_color normal
38	38	---------> set -l variable _$user_variable_name
33	33	---------> set -l variable_done "$variable"_done
6	140	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
12	106	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
34	34	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
66	668	--------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
31	31	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
30	30	---------> set -l default default_done
116	254	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
45	45	----------> count $argv
56	56	----------> set default "$argv[2]"
37	37	----------> set default_done "$argv[3]"
36	36	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
7	139	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
11	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
33	33	-----------> set -g $variable_done $default_done
60	644	--------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
32	32	---------> set -l user_variable_name "$argv[1]"
25	25	---------> set -l user_variable
4	30	---------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
26	26	----------> set -q $user_variable_name
25	25	---------> set -l user_variable_bright
26	26	---------> set -l default default_done
118	241	---------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
42	42	----------> count $argv
47	47	----------> set default "$argv[2]"
34	34	----------> set default_done "$argv[3]"
35	35	---------> set -l variable _$user_variable_name
32	32	---------> set -l variable_done "$variable"_done
6	138	---------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
28	28	----------> not set -q $variable
12	104	----------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
27	27	-----------> test -n "$user_variable"
33	33	-----------> set -g $variable $default
32	32	-----------> set -g $variable_done $default_done
28	28	-------> set -g ___fish_git_prompt_init
37	37	------> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
236	4983	------> set -l informative (command git config --bool bash.showInformativeStatus)
4747	4747	-------> command git config --bool bash.showInformativeStatus
197	6174	------> set -l dirty (command git config --bool bash.showDirtyState)
5977	5977	-------> command git config --bool bash.showDirtyState
13	72	------> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
33	33	-------> not set -q dirty[1]
26	26	-------> set -q __fish_git_prompt_showdirtystate
138	3891	------> set -l untracked (command git config --bool bash.showUntrackedFiles)
3753	3753	-------> command git config --bool bash.showUntrackedFiles
8	63	------> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
30	30	-------> not set -q untracked[1]
25	25	-------> set -q __fish_git_prompt_showuntrackedfiles
10	248	------> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
34	34	-------> test "true" = $inside_worktree
10	151	-------> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
26	26	--------> test "$informative" = true
6	29	--------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
23	23	---------> set -q __fish_git_prompt_show_informative_status
3	30	--------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
27	27	---------> test "$dirty" = true
4	27	--------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
23	23	---------> set -q __fish_git_prompt_showstashstate
4	29	--------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
25	25	---------> test "$untracked" = true
7	53	-------> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
23	23	--------> set -q __fish_git_prompt_showupstream
23	23	--------> set -q __fish_git_prompt_show_informative_status
34	34	------> set -l branch_color $___fish_git_prompt_color_branch
31	31	------> set -l branch_done $___fish_git_prompt_color_branch_done
4	27	------> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
23	23	-------> set -q __fish_git_prompt_showcolorhints
3	29	------> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
26	26	-------> test -n "$w"
3	27	------> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
24	24	-------> test -n "$i"
3	26	------> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
23	23	-------> test -n "$s"
3	27	------> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
24	24	-------> test -n "$u"
130	178	------> set b (string replace refs/heads/ '' -- $b)
48	48	-------> string replace refs/heads/ '' -- $b
28	28	------> set -q __fish_git_prompt_shorten_branch_char_suffix
31	31	------> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
5	53	------> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
48	48	-------> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
10	73	------> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
30	30	-------> test -n "$b"
33	33	-------> set b "$branch_color$b$branch_done"
4	30	------> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
26	26	-------> test -n "$c"
3	27	------> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
24	24	-------> test -n "$r"
3	27	------> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
24	24	-------> test -n "$p"
32	32	------> set -l f "$w$i$s$u"
4	28	------> if test -n "$f"
        set f "$space$f"
    ...
24	24	-------> test -n "$f"
31	31	------> set -l format $argv[1]
4	30	------> if test -z "$format"
        set format " (%s)"
    ...
26	26	-------> test -z "$format"
113	113	------> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
6	41	---> if test -z $branch_name
    return
  ...
35	35	----> test -z $branch_name
123	167	---> echo -s (set_color normal) " on "
44	44	----> set_color normal
182	8372	---> set -l dirty (command git status --porcelain ^/dev/null)
8190	8190	----> command git status --porcelain ^/dev/null
12	94	---> if test -z "$dirty"
    set_color --bold green
  else
    set_color --bold red
  ...
38	38	----> test -z "$dirty"
44	44	----> set_color --bold red
142	179	---> echo -s "$branch_name" (set_color normal)
37	37	----> set_color normal
172	8103	---> set -l unpushed_changes (git cherry -v ^/dev/null)
7931	7931	----> git cherry -v ^/dev/null
5	44	---> if test -z "$unpushed_changes"
    return
  ...
39	39	----> test -z "$unpushed_changes"
227	329	---> echo -s " with " (set_color --bold magenta) "unpushed" (set_color normal)
49	49	----> set_color --bold magenta
53	53	----> set_color normal
41	81	--> _node
6	40	---> if test -f ./package.json
    echo -s (set_color --bold green) ' ⬢ ' (node -v) (set_color normal)
  ...
34	34	----> test -f ./package.json
45	200	> fish_title
117	155	-> echo (status current-command)
38	38	--> status current-command
48	109	> __fish_disable_bracketed_paste exit
61	61	-> printf "\e[?2004l"
50	251	> fish_title exit
157	201	-> echo (status current-command)
44	44	--> status current-command
96	96	> exit
33	86	> __fish_disable_bracketed_paste 0
53	53	-> printf "\e[?2004l"
